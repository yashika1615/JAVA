Java Multithreading and Concurrency Interview Questions
Multithreading and Synchronization are considered as the typical chapter in java programming. In game development companies, multithreading related interview questions are asked mostly. A list of frequently asked java multithreading and concurrency interview questions is given below.

Multithreading Interview Questions
(1) What is multithreading?
Multithreading is a process of executing multiple threads simultaneously. Multithreading is used to obtain the multitasking. It consumes less memory and gives the fast and efficient performance. Its main advantages are:

What do you mean by Multithreading? Why is it important?
Multithreading means multiple threads and is considered one of the most important features of Java. As the name suggests, it is the ability of a CPU to execute multiple threads independently at the same time but share the process resources simultaneously. Its main purpose is to provide simultaneous execution of multiple threads to utilize the CPU time as much as possible. It is a Java feature where one can subdivide the specific program into two or more threads to make the execution of the program fast and easy.

Multithreading Interview Questions in Java for Freshers
1. What is the start() and run() method of Thread class?
start(): In simple words, the start() method is used to start or begin the execution of a newly created thread. When the start() method is called, a new thread is created and this newly created thread executes the task that is kept in the run() method. One can call the start() method only once.  

run(): In simple words, the run() method is used to start or begin the execution of the same thread. When the run() method is called, no new thread is created as in the case of the start() method. This method is executed by the current thread. One can call the run() method multiple times. 

2. What is Thread in Java?
Threads are basically the lightweight and smallest unit of processing that can be managed independently by a scheduler. Threads are referred to as parts of a process that simply let a program execute efficiently with other parts or threads of the process at the same time. Using threads, one can perform complicated tasks in the easiest way. It is considered the simplest way to take advantage of multiple CPUs available in a machine. They share the common address space and are independent of each other. 

3. What are the two ways of implementing thread in Java?
There are basically two ways of implementing thread in java as given below: 

Extending the Thread class
Extending the Thread class
Example:

class MultithreadingDemo extends Thread 
{   
  public void run() 
 {   
     System.out.println("My thread is in running state.");    
 } 
  public static void main(String args[]) 
 {   
    MultithreadingDemo obj=new MultithreadingDemo();  
        obj.start();  
  }  
} 
Output:

My thread is in running state.
Implementing Runnable interface in Java
Example:  

class MultithreadingDemo implements Runnable 
{  
   public void run() 
 {  
      System.out.println("My thread is in running state.");  
  }  
    public static void main(String args[]) 
 {  
      MultithreadingDemo obj=new MultithreadingDemo();   
      Threadtobj =new Thread(obj);       tobj.start();  
 }   
} 
Output: 

My thread is in running state. 

4. What's the difference between thread and process?
Thread: It simply refers to the smallest units of the particular process. It has the ability to execute different parts (referred to as thread) of the program at the same time.  

Process: It simply refers to a program that is in execution i.e., an active program. A process can be handled using PCB (Process Control Block). 

5. What’s the difference between class lock and object lock?
Class Lock: In java, each and every class has a unique lock usually referred to as a class level lock. These locks are achieved using the keyword ‘static synchronized’ and can be used to make static data thread-safe. It is generally used when one wants to prevent multiple threads from entering a synchronized block. 

Example:  

public class ClassLevelLockExample  
{    
  public void classLevelLockMethod()  
 {       
     synchronized (ClassLevelLockExample.class)  
       {         
            //DO your stuff here       
       }    
 } 
} 
Object Lock: In java, each and every object has a unique lock usually referred to as an object-level lock. These locks are achieved using the keyword ‘synchronized’ and can be used to protect non-static data. It is generally used when one wants to synchronize a non-static method or block so that only the thread will be able to execute the code block on a given instance of the class.  

Example:  

public class ObjectLevelLockExample  
{    
  public void objectLevelLockMethod()  
 {   
     synchronized (this)  
       {     
            //DO your stuff here   
       } 
 }
} 
Explore InterviewBit’s Exclusive Live Events
By

Learn How To Design Seamless Notification Services
Naman Bhalla, Lead Instructor

30 Jul '24
•
7:30 PM
|
Certificate Included
Know More
Reserve My Spot

Transition from Non-Data Science to Data Science roles
Pulkit Aneja, Top-rated Data Science instructor

30 Jul '24
•
7:30 PM
|
Certificate Included
Know More
Reserve My Spot

Top Design Patterns in Java
Deepak Kasera, Instructor

1 Aug '24
•
7:30 PM
|
Certificate Included
Know More
Reserve My Spot

Introduction to Cloud Computing with AWS
Deepak Kasera, Instructor

3 Aug '24
•
5:00 PM
|
Certificate Included
Know More
Reserve My Spot

Get Noticed by Employers: Add AI & ML Projects to Your CV
Avijit Roy, Lead Data Science instructor

3 Aug '24
•
5:00 PM
|
Certificate Included
Know More
Reserve My Spot

SOLID Principles Every Developer Must Know
Pragy Agarwal, Senior Software Engineer

8 Aug '24
•
7:30 PM
|
Certificate Included
Know More
Reserve My Spot
6. What's the difference between User thread and Daemon thread?
User and Daemon are basically two types of thread used in Java by using a ‘Thread Class’.  

User Thread (Non-Daemon Thread): In Java, user threads have a specific life cycle and its life is independent of any other thread. JVM (Java Virtual Machine) waits for any of the user threads to complete its tasks before terminating it. When user threads are finished, JVM terminates the whole program along with associated daemon threads. 

Daemon Thread: In Java, daemon threads are basically referred to as a service provider that provides services and support to user threads. There are basically two methods available in thread class for daemon thread: setDaemon() and isDaemon(). 

User Thread vs Daemon Thread

User Thread	Daemon Thread 
JVM waits for user threads to finish their tasks before termination. 	JVM does not wait for daemon threads to finish their tasks before termination.
These threads are normally created by the user for executing tasks concurrently. 	These threads are normally created by JVM.
They are used for critical tasks or core work of an application. 	They are not used for any critical tasks but to do some supporting tasks.
These threads are referred to as high-priority tasks, therefore are required for running in the foreground. 	These threads are referred to as low priority threads, therefore are especially required for supporting background tasks like garbage collection, releasing memory of unused objects, etc. 
7. How can we create daemon threads?
We can create daemon threads in java using the thread class setDaemon(true). It is used to mark the current thread as daemon thread or user thread. isDaemon() method is generally used to check whether the current thread is daemon or not. If the thread is a daemon, it will return true otherwise it returns false.  
Example:   
Program to illustrate the use of setDaemon() and isDaemon() method. 

public class DaemonThread extends Thread 
{ 
   public DaemonThread(String name){ 
       super(name); 
   } 
   public void run() 
   {  
       // Checking whether the thread is Daemon or not 
       if(Thread.currentThread().isDaemon()) 
       {  
           System.out.println(getName() + " is Daemon thread");  
       }    
       else 
       {  
           System.out.println(getName() + " is User thread");  
       }  
   }   
   public static void main(String[] args) 
   {  
       DaemonThread t1 = new DaemonThread("t1"); 
       DaemonThread t2 = new DaemonThread("t2"); 
       DaemonThread t3 = new DaemonThread("t3");  
       // Setting user thread t1 to Daemon 
       t1.setDaemon(true);       
       // starting first 2 threads  
       t1.start();  
       t2.start();   
       // Setting user thread t3 to Daemon 
       t3.setDaemon(true);  
       t3.start();         
   }  
} 
Output:  

t1 is Daemon thread 
t3 is Daemon thread 
t2 is User thread 
But one can only call the setDaemon() method before start() method otherwise it will definitely throw IllegalThreadStateException as shown below:   

public class DaemonThread extends Thread 
{ 
   public void run() 
   { 
       System.out.println("Thread name: " + Thread.currentThread().getName()); 
       System.out.println("Check if its DaemonThread: "  
                       + Thread.currentThread().isDaemon()); 
   } 
   public static void main(String[] args) 
   { 
       DaemonThread t1 = new DaemonThread(); 
       DaemonThread t2 = new DaemonThread(); 
       t1.start();         
       // Exception as the thread is already started 
       t1.setDaemon(true); 
       t2.start(); 
   } 
} 
Output:  

Thread name: Thread-0 
Check if its DaemonThread: false 

Start Your Coding Journey With Tracks
Master Data Structures and Algorithms with our Learning Tracks
Topic Buckets
Mock Assessments
Reading Material
View Tracks
8. What are the wait() and sleep() methods?
wait(): As the name suggests, it is a non-static method that causes the current thread to wait and go to sleep until some other threads call the notify () or notifyAll() method for the object’s monitor (lock). It simply releases the lock and is mostly used for inter-thread communication. It is defined in the object class, and should only be called from a synchronized context. 

Example:  

synchronized(monitor) 
{ 
monitor.wait();       Here Lock Is Released by Current Thread  
} 
sleep(): As the name suggests, it is a static method that pauses or stops the execution of the current thread for some specified period. It doesn’t release the lock while waiting and is mostly used to introduce pause on execution. It is defined in thread class, and no need to call from a synchronized context.  

Example:  

synchronized(monitor) 
{ 
Thread.sleep(1000);     Here Lock Is Held by The Current Thread 
//after 1000 milliseconds, the current thread will wake up, or after we call that is interrupt() method 
} 
9. What’s the difference between notify() and notifyAll()?
notify(): It sends a notification and wakes up only a single thread instead of multiple threads that are waiting on the object’s monitor.


notifyAll(): It sends notifications and wakes up all threads and allows them to compete for the object's monitor instead of a single thread. 


10. Why wait(), notify(), and notifyAll() methods are present in Object class?
We know that every object has a monitor that allows the thread to hold a lock on the object. But the thread class doesn't contain any monitors. Thread usually waits for the object’s monitor (lock) by calling the wait() method on an object, and notify other threads that are waiting for the same lock using notify() or notifyAll() method.  Therefore, these three methods are called on objects only and allow all threads to communicate with each that are created on that object.

11. What is Runnable and Callable Interface? Write the difference between them.
Both the interfaces are generally used to encapsulate tasks that are needed to be executed by another thread. But there are some differences between them as given below: 

Running Interface: This interface is basically available in Java right from the beginning. It is simply used to execute code on a concurrent thread.  
Callable Interface: This interface is basically a new one that was introduced as a part of the concurrency package. It addresses the limitation of runnable interfaces along with some major changes like generics, enum, static imports, variable argument method, etc. It uses generics to define the return type of object.   

public interface Runnable  
{   
  public abstract void run(); 
}  
public interface Callable<V>  
{    
V call() throws Exception;  
} 
Runnable Interface vs Callable Interface

Runnable Interface	Callable Interface 
It does not return any result and therefore, cannot throw a checked exception. 	It returns a result and therefore, can throw an exception.
It cannot be passed to invokeAll method. 	It can be passed to invokeAll method.
It was introduced in JDK 1.0.	It was introduced in JDK 5.0, so one cannot use it before Java 5. 
It simply belongs to Java.lang.	It simply belongs to java.util.concurrent. 
It uses the run() method to define a task.	It uses the call() method to define a task. 
To use this interface, one needs to override the run() method. 	To use this interface, one needs to override the call() method.
12. What are the benefits of using Multithreading?
There are various benefits of multithreading as given below:

Allow the program to run continuously even if a part of it is blocked. 
Improve performance as compared to traditional parallel programs that use multiple processes. 
Allows to write effective programs that utilize maximum CPU time
Improves the responsiveness of complex applications or programs. 
Increase use of CPU resources and reduce costs of maintenance. 
Saves time and parallelism tasks. 
If an exception occurs in a single thread, it will not affect other threads as threads are independent. 
Less resource-intensive than executing multiple processes at the same time. 

Discover your path to a  
Successful Tech Career For FREE!
Answer 4 simple questions & get a career plan tailored for you
Interview Process
CTC & Designation
Projects on the Job
Try It Out
2 Lakh+ Roadmaps Created
13. Explain thread pool?
A Thread pool is simply a collection of pre-initialized or worker threads at the start-up that can be used to execute tasks and put back in the pool when completed. It is referred to as pool threads in which a group of fixed-size threads is created.  By reducing the number of application threads and managing their lifecycle, one can mitigate the issue of performance using a thread pool. Using threads, performance can be enhanced and better system stability can occur. To create the thread pools, java.util.concurrent.Executors class usually provides factory methods.

14. What’s the purpose of the join() method?
join() method is generally used to pause the execution of a current thread unless and until the specified thread on which join is called is dead or completed. To stop a thread from running until another thread gets ended, this method can be used. It joins the start of a thread execution to the end of another thread’s execution. It is considered the final method of a thread class.

15. What do you mean by garbage collection?
Garbage collection is basically a process of managing memory automatically. It uses several GC algorithms among which the popular one includes Mark and Sweep. The process includes three phases i.e., marking, deletion, and compaction/copying. In simple words, a garbage collector finds objects that are no longer required by the program and then delete or remove these unused objects to free up the memory space.

16. Explain the meaning of the deadlock and when it can occur?
Deadlock, as the name suggests, is a situation where multiple threads are blocked forever. It generally occurs when multiple threads hold locks on different resources and are waiting for other resources to complete their task.


The above diagram shows a deadlock situation where two threads are blocked forever.  Thread 1 is holding Object 1 but needs object 2 to complete processing whereas Thread 2 is holding Object 2 but needs object 1 first. In such conditions, both of them will hold lock forever and will never complete tasks.

17. Explain volatile variables in Java?
A volatile variable is basically a keyword that is used to ensure and address the visibility of changes to variables in multithreaded programming. This keyword cannot be used with classes and methods, instead can be used with variables. It is simply used to achieve thread-safety. If you mark any variable as volatile, then all the threads can read its value directly from the main memory rather than CPU cache, so that each thread can get an updated value of the variable.

18. How do threads communicate with each other?
Threads can communicate using three methods i.e., wait(), notify(), and notifyAll().

19. Can two threads execute two methods (static and non-static concurrently)?
Yes, it is possible. If both the threads acquire locks on different objects, then they can execute concurrently without any problem.

20. What is the purpose of the finalize() method?
Finalize() method is basically a method of Object class specially used to perform cleanup operations on unmanaged resources just before garbage collection. It is not at all intended to be called a normal method. After the complete execution of finalize() method, the object gets destroyed automatically.

Multithreading Interview Questions in Java for Experienced
1. What is ConcurrentHashMap and Hashtable? In java, why is ConcurrentHashMap considered faster than Hashtable?
ConcurrentHashMap: It was introduced in Java 1.5 to store data using multiple buckets. As the name suggests, it allows concurrent read and writes operations to the map. It only locks a certain portion of the map while doing iteration to provide thread safety so that other readers can still have access to the map without waiting for iteration to complete.  

Hashtable: It is a thread-safe legacy class that was introduced in old versions of java to store key or value pairs using a hash table.  It does not provide any lock-free read, unlike ConcurrentHashMap. It just locks the entire map while doing iteration. 

ConcurrentHashMap and Hashtable, both are thread-safe but ConcurrentHashMap generally avoids read locks and improves performance, unlike Hashtable. ConcurrentHashMap also provides lock-free reads, unlike Hashtable. Therefore, ConcurrentHashMap is considered faster than Hashtable especially when the number of readers is more as compared to the number of writers. 

2. What is thread starvation?
Thread starvation is basically a situation or condition where a thread won’t be able to have regular access to shared resources and therefore is unable to proceed or make progress. This is because other threads have high priority and occupy the resources for too long. This usually happens with low-priority threads that do not get CPU for its execution to carry on. 


3. What is Livelock? What happens when it occurs?
Similar to deadlock, livelock is also another concurrency problem. In this case, the state of threads changes between one another without making any progress. Threads are not blocked but their execution is stopped due to the unavailability of resources.

4. What is BlockingQueue?
BlockingQueue basically represents a queue that is thread-safe. Producer thread inserts resource/element into the queue using put() method unless it gets full and consumer thread takes resources from the queue using take() method until it gets empty. But if a thread tries to dequeue from an empty queue, then a particular thread will be blocked until some other thread inserts an item into the queue, or if a thread tries to insert an item into a queue that is already full, then a particular thread will be blocked until some threads take away an item from the queue. 


Example: 

package org.arpit.java2blog; 
 
import java.util.concurrent.ArrayBlockingQueue; 
import java.util.concurrent.BlockingQueue; 
 
public class BlockingQueuePCExample { 
 
   public static void main(String[] args) { 
 
       BlockingQueue<String> queue=new ArrayBlockingQueue<>(5); 
       Producer producer=new Producer(queue); 
       Consumer consumer=new Consumer(queue); 
       Thread producerThread = new Thread(producer); 
       Thread consumerThread = new Thread(consumer); 
 
       producerThread.start(); 
       consumerThread.start(); 
 
   } 
 
   static class Producer implements Runnable { 
 
       BlockingQueue<String> queue=null; 
 
       public Producer(BlockingQueue queue) { 
           super(); 
           this.queue = queue; 
       } 
 
       @Override 
       public void run() { 
 
               try { 
                   System.out.println("Producing element 1"); 
                   queue.put("Element 1"); 
                   Thread.sleep(1000); 
                   System.out.println("Producing element 2"); 
                   queue.put("Element 2"); 
                   Thread.sleep(1000); 
                   System.out.println("Producing element 3"); 
                   queue.put("Element 3"); 
               } catch (InterruptedException e) { 
 
                   e.printStackTrace(); 
               } 
       } 
   } 
 
   static class Consumer implements Runnable { 
 
       BlockingQueue<String> queue=null; 
 
       public Consumer(BlockingQueue queue) { 
           super(); 
           this.queue = queue; 
       } 
 
       @Override 
       public void run() { 
 
           while(true) 
           { 
               try { 
                   System.out.println("Consumed "+queue.take()); 
               } catch (InterruptedException e) { 
                   e.printStackTrace(); 
               } 
           } 
       } 
 
   } 
} 
Output: 

Producing element 1 
Consumed Element 1 
Producing element 2 
Consumed Element 2 
Producing element 3 
Consumed Element 3
5. Can you start a thread twice?
No, it's not at all possible to restart a thread once a thread gets started and completes its execution. Thread only runs once and if you try to run it for a second time, then it will throw a runtime exception i.e., java.lang.IllegalThreadStateException. 

Example: 

public class TestThreadTwice1 extends Thread{   
public void run(){   
System.out.println(" thread is executing now........");   
}   
public static void main(String args[]){   
TestThreadTwice1 t1=new TestThreadTwice1();   
t1.start();   
t1.start();   
}   
}   
Output:

thread is executing now........ 
Exception in thread "main" java.lang.IllegalThreadStateException  
6. Explain context switching.
Context switching is basically an important feature of multithreading. It is referred to as switching of CPU from one thread or process to another one. It allows multiple processes to share the same CPU. In context switching, the state of thread or process is stored so that the execution of the thread can be resumed later if required. 

7. What is CyclicBarrier and CountDownLatch?
CyclicBarrier and CountDownLatch, both are required for managing multithreaded programming. But there is some difference between them as given below: 

CyclicBarrier: It is a tool to synchronize threads processing using some algorithm. It enables a set of threads to wait for each other till they reach a common execution point or common barrier points, and then let them further continue execution. One can reuse the same CyclicBarrier even if the barrier is broken by setting it. 

CountDownLatch: It is a tool that enables main threads to wait until mandatory operations are performed and completed by other threads. In simple words, it makes sure that a thread waits until the execution in another thread completes before it starts its execution. One cannot reuse the same CountDownLatch once the count reaches 0. 


8. What do you mean by inter-thread communication?
Inter-thread communication, as the name suggests, is a process or mechanism using which multiple threads can communicate with each other. It is especially used to avoid thread polling in java and can be obtained using wait(), notify(), and notifyAll() methods. 

9. What is Thread Scheduler and Time Slicing?
Thread Scheduler: It is a component of JVM that is used to decide which thread will execute next if multiple threads are waiting to get the chance of execution. By looking at the priority assigned to each thread that is READY, the thread scheduler selects the next run to execute. To schedule the threads, it mainly uses two mechanisms: Preemptive Scheduling and Time slicing scheduling.  

Time Slicing: It is especially used to divide CPU time and allocate them to active threads. In this, each thread will get a predefined slice of time to execute. When the time expires, a particular thread has to wait till other threads get their chances to use their time in a round-robin fashion. Every running thread will get executed for a fixed time period. 

10. What is a shutdown hook?
A shutdown hook is simply a thread that is invoked implicitly before JVM shuts down. It is one of the most important features of JVM because it provides the capacity to do resource cleanup or save application state JVM shuts down.  By calling the halt(int) method of the Runtime class, the shutdown hook can be stopped. Using the following method, one can add a shutdown hook. 

public void addShutdownHook(Thread hook){}     
Runtime r=Runtime.getRuntime();   
r.addShutdownHook(new MyThread());
11. What is busy spinning?
Busy Spinning, also known as Busy-waiting, is a technique in which one thread waits for some condition to happen, without calling wait or sleep methods and releasing the CPU. In this condition, one can pause a thread by making it run an empty loop for a certain time period, and it does not even give CPY control. Therefore, it is used to preserve CPU caches and avoid the cost of rebuilding cache.

12. What is synchronized method and synchronized block? Which one should be preferred?
Synchronized Method: In this method, the thread acquires a lock on the object when they enter the synchronized method and releases the lock either normally or by throwing an exception when they leave the method.  No other thread can use the whole method unless and until the current thread finishes its execution and release the lock. It can be used when one wants to lock on the entire functionality of a particular method. 

Synchronized Block: In this method, the thread acquires a lock on the object between parentheses after the synchronized keyword, and releases the lock when they leave the block. No other thread can acquire a lock on the locked object unless and until the synchronized block exists. It can be used when one wants to keep other parts of the programs accessible to other threads.
 
Synchronized blocks should be preferred more as it boosts the performance of a particular program. It only locks a certain part of the program (critical section) rather than the entire method and therefore leads to less contention.

13. Explain thread priority.
Thread priority simply means that threads with the highest priority will get a chance for execution prior to low-priority threads. One can specify the priority but it's not necessary that the highest priority thread will get executed before the lower-priority thread. Thread scheduler assigns processor to thread on the basis of thread priority. The range of priority changes between 1-10 from lowest priority to highest priority. 


14. What do you mean by the ThreadLocal variable in Java?
ThreadLocal variables are special kinds of variables created and provided by the Java ThreadLocal class. These variables are only allowed to be read and written by the same thread. Two threads cannot be able to see each other’s ThreadLocal variable, so even if they will execute the same code, then there won't be any race condition and the code will be thread-safe.  

Example:  

public class ThreadLocalExp   
{   
     public static class MyRunnable implements Runnable    
   {   
       private ThreadLocal<Integer> threadLocal =   
              new ThreadLocal<Integer>();   
      @Override   
       public void run() {   
           threadLocal.set( (int) (Math.random() * 50D) );   
           try    
           {   
               Thread.sleep(1000);   
           } catch (InterruptedException e) {   
           }   
           System.out.println(threadLocal.get());   
       }   
   }   
   public static void main(String[] args)    
   {   
       MyRunnable runnableInstance = new MyRunnable();    
       Thread t1 = new Thread(runnableInstance);   
       Thread t2 = new Thread(runnableInstance);   
      // this will call run() method    
       t1.start();   
       t2.start();   
   }   
} 
Output: 

10 
33 
10 33 
15. What is semaphore?
Semaphore is regarded as a thread synchronization construct that is usually required to control and manage the access to the shared resource using counters. It simply sets the limit of the thread. The semaphore class is defined within the package java.util.concurrent and can be used to send signals between threads to avoid missed signals or to guard critical sections. It can also be used to implement resource pools or bounded collection.

16. Explain Thread Group. Why should we not use it?
ThreadGroup is a class that is used to create multiple groups of threads in a single object. This group of threads is present in the form of three structures in which every thread group has a parent except the initial thread. Thread groups can contain other thread groups also. A thread is only allowed to have access to information about its own thread group, not other thread groups. 

Previously in the old version of Java, the only functionality that did not work without a thread group was uncaughtException( Thread t, Throwable e). But now in Java 5 versions, there is Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler). So now even that works without thread groups and therefore, there is no need to use thread groups.  

t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler() 
{ 
@Override  
public void uncaughtException(Thread t, Throwable e)  
{  
System.out.println("exception occured:"+e.getMessage()); 
}  
}; 
17. What is the ExecutorService interface?
ExecutorService interface is basically a sub-interface of Executor interface with some additional methods or features that help in managing and controlling the execution of threads. It enables us to execute tasks asynchronously on threads.


Example: 

import java.util.concurrent.ExecutorService;   
import java.util.concurrent.Executors;   
import java.util.concurrent.TimeUnit;   
  
public class TestThread {   
                                   public static void main(final String[] arguments) throws InterruptedException {   
ExecutorService e = Executors.newSingleThreadExecutor();   
 
     try {   
       e.submit(new Thread());   
        System.out.println("Shutdown executor");   
        e.shutdown();   
        e.awaitTermination(5, TimeUnit.SECONDS);   
  } catch (InterruptedException ex) {   
       System.err.println("tasks interrupted");   
  } finally {   
  
        if (!e.isTerminated()) {   
           System.err.println("cancel non-finished tasks");   
     }   
        e.shutdownNow();   
        System.out.println("shutdown finished");   
  }   
  }   
  
  static class Task implements Runnable {   
        
     public void run() {   
          
        try {   
        Long duration = (long) (Math.random() * 20);   
           System.out.println("Running Task!");   
           TimeUnit.SECONDS.sleep(duration);   
     } catch (InterruptedException ex) {   
           ex.printStackTrace();   
     }   
  }   
 }          
}   
Output:

Shutdown executor 
shutdown finished
18. What will happen if we don’t override the thread class run() method?
Nothing will happen as such if we don’t override the run() method. The compiler will not show any error. It will execute the run() method of thread class and we will just don’t get any output because the run() method is with an empty implementation. 

Example:  

class MyThread extends Thread { 
  //don't override run() method 
} 
public class DontOverrideRun { 
  public static void main(String[] args) { 
         System.out.println("Started Main."); 
         MyThread thread1=new MyThread(); 
      thread1.start(); 
         System.out.println("Ended Main."); 
  } 
} 
Output: 

Started Main. 
Ended Main.  
19. What is the lock interface? Why is it better to use a lock interface rather than a synchronized block.?
Lock interface was introduced in Java 1.5 and is generally used as a synchronization mechanism to provide important operations for blocking.  

Advantages of using Lock interface over Synchronization block: 

Methods of Lock interface i.e., Lock() and Unlock() can be called in different methods. It is the main advantage of a lock interface over a synchronized block because the synchronized block is fully contained in a single method.  
Lock interface is more flexible and makes sure that the longest waiting thread gets a fair chance for execution, unlike the synchronization block.
20. Is it possible to call the run() method directly to start a new thread?
No, it's not possible at all. You need to call the start method to create a new thread otherwise run method won't create a new thread. Instead, it will execute in the current thread.

21. Is it possible that each thread can have its stack in multithreaded programming?
Of course, it is possible. In multithreaded programming, each thread maintains its own separate stack area in memory because of which every thread is independent of each other rather than dependent.

22. What is the synchronization process? Why use it?
Synchronization is basically a process in java that enables a simple strategy for avoiding thread interference and memory consistency errors. This process makes sure that resource will be only used one thread at a time when one thread tries to access a shared resource. It can be achieved in three different ways as given below: 

By the synchronized method
By synchronized block
By static synchronization
Syntax:  

synchronized (object) 
{        
   //statement to be synchronized 
} 
Conclusion
1. Conclusion
Overall, multithreading is a very essential part of Java and modern software development. It is very helpful in making the program more efficient and also reduces the usage of storage resources. In this article, we have discussed important interview questions related to multithreading along with answers that were asked mostly in the Interviews and will help you to crack your interviews.

Recommended Tutorials:
Practice
Java Developer Skills

MCQs on Multithreading in Java
1.
Multithreading is defined as...


A process where single process can have access to the information from different sources.

A process where two different processes can run simultaneously.

A process where two or more parts of the same process run simultaneously.

A process where different processes can have access to the same information.
2.
Name the method that is used to register a thread in a thread scheduler.


register()

run()

start()

None of the above
3.
When the thread is considered dead?


In sleep state

When it’s yet to start execution

When run method finishes

While waiting for I/O
4.
How can a thread be created in java multi-threading?


Extended Thread Class

Implementing Runnable Interface

Both A and B

None of the above
5.
Which of the following is not a valid constructor of the Thread class?


Thread (String name)

Thread (Runnable target, String name)

Thread (Runnable target, Object obj)

None of the above
6.
Predict the output of the following code:

class MyThread extends Thread  
{ 
  public void run()  
   {         
       System.out.println("Running");   
   } 
} 
class ThreadTest {
   public static void main(String args[]) throws InterruptedException  
        {         
             Runnable r = new MyThread(); // #1         
               Thread myThread = new Thread(r); // #2         
               myThread.start();     
       } 
}

Compilation error at statement #1

Compilation error at statement #2

Print ‘Running’ in the console

Doesn’t print any output in the console
7.
What is thread priority in Java?


Float

Integer

Double

None of the above
8.
Which of the following method needs to be defined by a class that is implementing java.lang.Runnable interface?


public void run()

public void start()

void run()

None of the above
9.
Name the method of the thread that is called before the run() method and carries out initialization.


Start()

Resume()

Suspend()

None of the above()
10.
In the following java program, what is the name of the thread?

class multithreaded_programing 
 { 
   public static void main(String args[]) 
   { 
         Thread t = Thread.currentThread(); 
         System.out.println(t);         
   } 
  }

Thread

Main

System

None of the above


Java Multithreading Interview Questions
What is the difference between Process and Thread?
What are the benefits of multi-threaded programming?
What is difference between user Thread and daemon Thread?
How can we create a Thread in Java?
What are different states in lifecycle of Thread?
Can we call run() method of a Thread class?
How can we pause the execution of a Thread for specific time?
What do you understand about Thread Priority?
What is Thread Scheduler and Time Slicing?
What is context-switching in multi-threading?
How can we make sure main() is the last thread to finish in Java Program?
How does thread communicate with each other?
Why thread communication methods wait(), notify() and notifyAll() are in Object class?
Why wait(), notify() and notifyAll() methods have to be called from synchronized method or block?
Why Thread sleep() and yield() methods are static?
How can we achieve thread safety in Java?
What is volatile keyword in Java
Which is more preferred - Synchronized method or Synchronized block?
How to create daemon thread in Java?
What is ThreadLocal?
What is Thread Group? Why it’s advised not to use it?
What is Java Thread Dump, How can we get Java Thread dump of a Program?
What is Deadlock? How to analyze and avoid deadlock situation?
What is Java Timer Class? How to schedule a task to run after specific interval?
What is Thread Pool? How can we create Thread Pool in Java?
What will happen if we don’t override Thread class run() method?
Java Concurrency Interview Questions
What is atomic operation? What are atomic classes in Java Concurrency API?
What is Lock interface in Java Concurrency API? What are it’s benefits over synchronization?
What is Executors Framework?
What is BlockingQueue? How can we implement Producer-Consumer problem using Blocking Queue?
What is Callable and Future?
What is FutureTask class?
What are Concurrent Collection Classes?
What is Executors Class?
What are some of the improvements in Concurrency API in Java 8?
Java Multithreading Interview Questions and Answers
What is the difference between Process and Thread?
A process is a self contained execution environment and it can be seen as a program or application whereas Thread is a single task of execution within the process. Java runtime environment runs as a single process which contains different classes and programs as processes. Thread can be called lightweight process. Thread requires less resources to create and exists in the process, thread shares the process resources.

What are the benefits of multi-threaded programming?
In Multi-Threaded programming, multiple threads are executing concurrently that improves the performance because CPU is not idle incase some thread is waiting to get some resources. Multiple threads share the heap memory, so it’s good to create multiple threads to execute some task rather than creating multiple processes. For example, Servlets are better in performance than CGI because Servlet support multi-threading but CGI doesn’t.

What is difference between user Thread and daemon Thread?
When we create a Thread in java program, it’s known as user thread. A daemon thread runs in background and doesn’t prevent JVM from terminating. When there are no user threads running, JVM shutdown the program and quits. A child thread created from daemon thread is also a daemon thread.

How can we create a Thread in Java?
There are two ways to create Thread in Java - first by implementing Runnable interface and then creating a Thread object from it and second is to extend the Thread Class. Read this post to learn more about creating threads in java.

What are different states in lifecycle of Thread?
When we create a Thread in java program, its state is New. Then we start the thread that change it's state to Runnable. Thread Scheduler is responsible to allocate CPU to threads in Runnable thread pool and change their state to Running. Other Thread states are Waiting, Blocked and Dead. Read this post to learn more about [life cycle of thread](/community/tutorials/thread-life-cycle-in-java-thread-states-in-java).
Can we call run() method of a Thread class?
Yes, we can call run() method of a Thread class but then it will behave like a normal method. To actually execute it in a Thread, we need to start it using **Thread.start()** method.
How can we pause the execution of a Thread for specific time?
We can use Thread class sleep() method to pause the execution of Thread for certain time. Note that this will not stop the processing of thread for specific time, once the thread awake from sleep, it's state gets changed to runnable and based on thread scheduling, it gets executed.
What do you understand about Thread Priority?
Every thread has a priority, usually higher priority thread gets precedence in execution but it depends on Thread Scheduler implementation that is OS dependent. We can specify the priority of thread but it doesn't guarantee that higher priority thread will get executed before lower priority thread. Thread priority is an _int_ whose value varies from 1 to 10 where 1 is the lowest priority thread and 10 is the highest priority thread.
What is Thread Scheduler and Time Slicing?
Thread Scheduler is the Operating System service that allocates the CPU time to the available runnable threads. Once we create and start a thread, it's execution depends on the implementation of Thread Scheduler. Time Slicing is the process to divide the available CPU time to the available runnable threads. Allocation of CPU time to threads can be based on thread priority or the thread waiting for longer time will get more priority in getting CPU time. Thread scheduling can't be controlled by java, so it's always better to control it from application itself.
What is context-switching in multi-threading?
Context Switching is the process of storing and restoring of CPU state so that Thread execution can be resumed from the same point at a later point of time. Context Switching is the essential feature for multitasking operating system and support for multi-threaded environment.
How can we make sure main() is the last thread to finish in Java Program?
We can use Thread join() method to make sure all the threads created by the program is dead before finishing the main function. Here is an article about [Thread join method](/community/tutorials/java-thread-join-example).
How does thread communicate with each other?
When threads share resources, communication between Threads is important to coordinate their efforts. Object class wait(), notify() and notifyAll() methods allows threads to communicate about the lock status of a resource. Check this post to learn more about [thread wait, notify and notifyAll](/community/tutorials/java-thread-wait-notify-and-notifyall-example).
Why thread communication methods wait(), notify() and notifyAll() are in Object class?
In Java every Object has a monitor and wait, notify methods are used to wait for the Object monitor or to notify other threads that Object monitor is free now. There is no monitor on threads in java and synchronization can be used with any Object, that's why it's part of Object class so that every class in java has these essential methods for inter thread communication.
Why wait(), notify() and notifyAll() methods have to be called from synchronized method or block?
When a Thread calls wait() on any Object, it must have the monitor on the Object that it will leave and goes in wait state until any other thread call notify() on this Object. Similarly when a thread calls notify() on any Object, it leaves the monitor on the Object and other waiting threads can get the monitor on the Object. Since all these methods require Thread to have the Object monitor, that can be achieved only by synchronization, they need to be called from synchronized method or block.
Why Thread sleep() and yield() methods are static?
Thread sleep() and yield() methods work on the currently executing thread. So there is no point in invoking these methods on some other threads that are in wait state. That’s why these methods are made static so that when this method is called statically, it works on the current executing thread and avoid confusion to the programmers who might think that they can invoke these methods on some non-running threads.
How can we achieve thread safety in Java?
There are several ways to achieve thread safety in java - synchronization, atomic concurrent classes, implementing concurrent Lock interface, using volatile keyword, using immutable classes and Thread safe classes. Learn more at [thread safety tutorial](/community/tutorials/thread-safety-in-java).
What is volatile keyword in Java
When we use volatile keyword with a variable, all the threads read it's value directly from the memory and don't cache it. This makes sure that the value read is the same as in the memory.
Which is more preferred - Synchronized method or Synchronized block?
Synchronized block is more preferred way because it doesn't lock the Object, synchronized methods lock the Object and if there are multiple synchronization blocks in the class, even though they are not related, it will stop them from execution and put them in wait state to get the lock on Object.
How to create daemon thread in Java?
Thread class setDaemon(true) can be used to create daemon thread in java. We need to call this method before calling start() method else it will throw IllegalThreadStateException.
What is ThreadLocal?
Java ThreadLocal is used to create thread-local variables. We know that all threads of an Object share it’s variables, so if the variable is not thread safe, we can use synchronization but if we want to avoid synchronization, we can use ThreadLocal variables. Every thread has its own ThreadLocal variable and they can use it gets () and set() methods to get the default value or change it’s value local to Thread. ThreadLocal instances are typically private static fields in classes that wish to associate the state with a thread. Check this post for small example program showing [ThreadLocal Example](/community/tutorials/java-threadlocal-example).
What is Thread Group? Why it’s advised not to use it?
ThreadGroup is a class which was intended to provide information about a thread group. ThreadGroup API is weak and it doesn't have any functionality that is not provided by Thread. It has two main features - to get the list of active threads in a thread group and to set the uncaught exception handler for the thread. But Java 1.5 has added _setUncaughtExceptionHandler(UncaughtExceptionHandler eh)_ method using which we can add uncaught exception handler to the thread. So ThreadGroup is obsolete and hence not advised to use anymore.

```
t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler(){

@Override
public void uncaughtException(Thread t, Throwable e) {
    System.out.println("exception occured:"+e.getMessage());
}
            
});
```
What is Java Thread Dump, How can we get Java Thread dump of a Program?
A thread dump is a list of all the threads active in the JVM, thread dumps are very helpful in analyzing bottlenecks in the application and analyzing deadlock situations. There are many ways using which we can generate Thread dump - Using Profiler, Kill -3 command, jstack tool, etc. I prefer jstack tool to generate thread dump of a program because it's easy to use and comes with JDK installation. Since it's a terminal-based tool, we can create a script to generate thread dump at regular intervals to analyze it later on. Read this post to know more about [generating thread dump in java](/community/tutorials/java-thread-dump-visualvm-jstack-kill-3-jcmd).
What is Deadlock? How to analyze and avoid deadlock situation?
Deadlock is a programming situation where two or more threads are blocked forever, this situation arises with at least two threads and two or more resources. To analyze a deadlock, we need to look at the java thread dump of the application, we need to look out for the threads with state as BLOCKED and then the resources it’s waiting to lock, every resource has a unique ID using which we can find which thread is already holding the lock on the object. Avoid Nested Locks, Lock Only What is Required and Avoid waiting indefinitely are common ways to avoid deadlock situation, read this post to learn how to [analyze deadlock in java](/community/tutorials/deadlock-in-java-example) with a sample program.
What is Java Timer Class? How to schedule a task to run after the specified interval?
java.util.Timer is a utility class that can be used to schedule a thread to be executed at a certain time in future. Java Timer class can be used to schedule a task to be run one-time or to be run at regular intervals. java.util.TimerTask is an **[abstract class](/community/tutorials/abstract-class-in-java "Abstract Class in Java with Example")** that implements Runnable interface and we need to extend this class to create our own TimerTask that can be scheduled using java Timer class. Check this post for [java Timer example](/community/tutorials/java-timer-timertask-example).
What is Thread Pool? How can we create Thread Pool in Java?
A thread pool manages the pool of worker threads, it contains a queue that keeps tasks waiting to get executed. A thread pool manages the collection of Runnable threads and worker threads execute Runnable from the queue. java.util.concurrent.Executors provide implementation of java.util.concurrent.Executor interface to create the thread pool in java. [Thread Pool Example](/community/tutorials/threadpoolexecutor-java-thread-pool-example-executorservice) program shows how to create and use Thread Pool in java. Or read [ScheduledThreadPoolExecutor Example](/community/tutorials/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example) to know how to schedule tasks after certain delay.
What will happen if we don’t override Thread class run() method?
Thread class run() method code is as shown below.

```
public void run() {
    if (target != null) {
        target.run();
    }
}
```

Above target set in the init() method of Thread class and if we create an instance of Thread class as `new TestThread()`, it's set to null. So nothing will happen if we don't override the run() method. Below is a simple example demonstrating this.

```
public class TestThread extends Thread {

	//not overriding Thread.run() method
	
	//main method, can be in other class too
	public static void main(String args[]){
		Thread t = new TestThread();
		System.out.println("Before starting thread");
		t.start();
		System.out.println("After starting thread");
	}
}
```

It will print only below output and terminate.

```
Before starting thread
After starting thread
```
Java Concurrency Interview Questions and Answers
What is atomic operation? What are atomic classes in Java Concurrency API?
Atomic operations are performed in a single unit of task without interference from other operations. Atomic operations are necessity in multi-threaded environment to avoid data inconsistency. int++ is not an atomic operation. So by the time one thread read its value and increment it by one, another thread has read the older value leading to the wrong result. To solve this issue, we will have to make sure that increment operation on count is atomic, we can do that using Synchronization but Java 5 java.util.concurrent.atomic provides wrapper classes for int and long that can be used to achieve this atomically without the usage of Synchronization. Go to this article to learn more about atomic concurrent classes.

What is Lock interface in Java Concurrency API? What are its benefits over synchronization?
Lock interface provides more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties and may support multiple associated Condition objects. The advantages of a lock are

it’s possible to make them fair
it’s possible to make a thread responsive to interruption while waiting on a Lock object.
it’s possible to try to acquire the lock, but return immediately or after a timeout if the lock can’t be acquired
it’s possible to acquire and release locks in different scopes, and in different orders
Read more at Java Lock Example.

What is Executors Framework?
In Java 5, Executor framework was introduced with the java.util.concurrent.Executor interface. The Executor framework is a framework for standardizing invocation, scheduling, execution, and control of asynchronous tasks according to a set of execution policies. Creating a lot many threads with no bounds to the maximum threshold can cause the application to run out of heap memory. So, creating a ThreadPool is a better solution as a finite number of threads can be pooled and reused. Executors framework facilitate the process of creating Thread pools in java. Check out this post to learn with example code to create thread pool using Executors framework.

What is BlockingQueue? How can we implement Producer-Consumer problem using Blocking Queue?
java.util.concurrent.BlockingQueue is a Queue that supports operations that wait for the queue to become non-empty when retrieving and removing an element, and wait for space to become available in the queue when adding an element. BlockingQueue doesn’t accept null values and throw NullPointerException if you try to store null value in the queue. BlockingQueue implementations are thread-safe. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control. BlockingQueue interface is part of the Java collections framework and it’s primarily used for implementing the producer-consumer problem. Check this post for producer-consumer problem implementation using BlockingQueue.

What is Callable and Future?
Java 5 introduced java.util.concurrent.Callable interface in concurrency package that is similar to Runnable interface but it can return any Object and able to throw Exception. The Callable interface uses Generics to define the return type of Object. Executors class provide useful methods to execute Callable in a thread pool. Since callable tasks run in parallel, we have to wait for the returned Object. Callable tasks return java.util.concurrent.Future object. Using Future we can find out the status of the Callable task and get the returned Object. It provides the get() method that can wait for the Callable to finish and then return the result. Check this post for [Callable Future Example](/community/tutorials/java-callable-future-example).
What is FutureTask Class?
FutureTask is the base implementation class of Future interface and we can use it with Executors for asynchronous processing. Most of the time we don't need to use FutureTask class but it comes real handy if we want to override some of the methods of Future interface and want to keep most of the base implementation. We can just extend this class and override the methods according to our requirements. Check out **[Java FutureTask Example](/community/tutorials/java-futuretask-example-program "Java FutureTask Example Program")** post to learn how to use it and what are different methods it has.
What are Concurrent Collection Classes?
Java Collection classes are fail-fast which means that if the Collection will be changed while some thread is traversing over it using iterator, the iterator.next() will throw ConcurrentModificationException. Concurrent Collection classes support full concurrency of retrievals and adjustable expected concurrency for updates. Major classes are ConcurrentHashMap, CopyOnWriteArrayList and CopyOnWriteArraySet, check this post to learn [how to avoid ConcurrentModificationException when using iterator](/community/tutorials/java-util-concurrentmodificationexception).
What is Executors Class?
Executors class provide utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes. Executors class can be used to easily create Thread Pool in java, also this is the only class supporting execution of Callable implementations.
What are some of the improvements in Concurrency API in Java 8?
Some important concurrent API enhancements are:

-   ConcurrentHashMap compute(), forEach(), forEachEntry(), forEachKey(), forEachValue(), merge(), reduce() and search() methods.
-   CompletableFuture that may be explicitly completed (setting its value and status).
-   Executors newWorkStealingPool() method to create a work-stealing thread pool using all available processors as its target parallelism level.



What is Multithreading in Java? Why is it important?
Multithreading in Java is a programming concept that refers to small tasks running simultaneously. Let's take an example of multithreading as our computer or mobile phones, which allows us to run various tasks at once. Its main purpose is to enable multiple threads to run simultaneously, maximizing CPU usage and improving program execution speed. This Java feature allows a program to be divided into multiple threads for faster and easier execution.

Multithreading Interview Questions in Java for Freshers
1.What is a thread in Java?
Threads are referred to as the smallest parts of a process that simply let a program execute efficiently with other parts or threads of the process at the same time. They share a common address space and are independent of each other. In Java, there are two ways of creating threads:

Via Thread class
Via Runnable interface
2. What are the two ways of implementing threads in Java?
The two ways of implementing threads in Java are as follows:

Via Thread class
Java
class SampleMultithreading extends Thread {
    public void run() {
        System.out.println("My thread is currently running.");
    }

    public static void main(String args[]) {
        SampleMultithreading obj = new SampleMultithreading();
        obj.start();
    }
}

Output: 

My thread is currently running.

2. Via Runnable Interface

Java
class SampleMultithreading implements Runnable {
    public void run() {
        System.out.println("My thread is currently running.");
    }

    public static void main(String args[]) {
        SampleMultithreading obj = new SampleMultithreading();
        Thread tobj = new Thread(obj);
        tobj.start();
    }
}
You can also try this code with Online Java Compiler
Run Code

Output:

 My thread is currently running.
3. What is multitasking in an operating system?
Multitasking is a feature in an operating system that divides system resources among tasks/processes and switches between the tasks/processes while they are executing over and over again. This gives the perception of 2 or more tasks running concurrently. Multitasking is of two types:

→ Process-based multitasking

→ Thread-based multitasking

4.  What are the benefits of using Multithreading?
Multithreading possesses various benefits described below:

It increases the use of CPU resources.
Does not get blocked easily if some parts of it are blocked
It allows the programs to utilize maximum CPU time
Improves the responsiveness of the program.
It allows parallelism.
5. What is a thread lifecycle?
A thread at any instant of time can be found in any one of the following states:

New
Runnable
Blocked
Waiting
Timed waiting
Terminated
6. What is the difference between a thread and a process?
A program in execution is called a process, while the smallest independent units in a process are called a thread.

7. What is the task of the main thread?
The main Thread is a thread contained in every program created by the JVM at the start of the program when the main() function is invoked with the main Thread as depicted from the output perceived from pseudo-code illustration.

System.out.println("coding ninjas");
Output: coding ninjas
System.out.println(Thread.getname().currentthread()); 
Output: main
8. What are the different types of threads in Java?
There are two types of threads in Java as follows:

User Thread(Non-daemon thread)
Daemon Thread
9. What is the start() and run() method of Thread class?
Start(): The start() method is used to start or begin the execution of a newly created thread. When the start() method is called, a new thread is created, and this newly created Thread executes the task that is kept in the run() method. One can call the start() method only once.

run():  The run() method is used to start or begin the execution of the same Thread. When the run() method is called, no new thread is created, as in the case of the start() method. This method is executed by the current Thread. One can call the run() method multiple times. 

10. How to set the name of the thread?
A method named as setName() is there which is used to change or set the names of the threads.

thread_class_object.setName("Name_thread_here");
You can also try this code with Online Java Compiler
Run Code
11. What do you mean by garbage collection?
Garbage collection is a process of managing memory automatically. A garbage collector finds objects that are no longer required by the program and then deletes or removes these unused objects to free up memory space. It uses several GC algorithms. One popular name of the algorithm is  Mark and Sweep.

12. What is thread Starvation?
When low-priority threads do not get CPU for their execution because high-priority threads occupy the CPU for long periods of time, this phenomenon is called thread starvation. This makes the Thread unable to progress.

13. What is thread priority?
In Java, every Thread has a priority which is represented by the numbers from 1 to 10. The default priority is set to 5, the minimum priority is set to one, and the maximum priority is set to 10. Here, three constants are defined as NORM_PRIORITY, MIN_PRIORITY, and MAX_PRIORITY.

14. What is context switching
Context Switching is referred to as switching the CPU from one Thread or process to another one. In context switching, the state of the Thread is stored so that the next time the execution of the Thread is required, it can be resumed from the same point.

15. What do you mean by inter-thread communication?
It is a mechanism using which multiple threads can communicate with each other. It is especially used to avoid thread polling in Java and can be obtained using wait(), notify(), and notifyAll() methods.

16. What do you mean by finalize() method?
The finalize() method in Java was defined in the Object class before Java version 9. It was supposed to be used for performing cleanup operations on an object before it was garbage collected. After the release of Java 9, this method has been deprecated and it is no longer recommended for managing memory.

Multithreading Interview Questions in Java for Experienced
17. What is the purpose of the finalize() method?
The finalize method in Java is used for performing cleanup operations on objects about to be garbage collected by the JVM. When an object becomes eligible for garbage collection, the JVM checks for a finalize() method and calls it before cleaning the memory. This method can be overridden to define custom cleanup logic. Let's look at the basic syntax of this overriding this method.

class MyClass {
   // Constructor and other methods
   
   // Custom finalize() method for cleanup
   protected void finalize() {
       // Perform resource cleanup here
   }
}
18. What is a semaphore?
Semaphore is regarded as a thread synchronization system that is usually required to control and manage the access to the shared resource using counters. The semaphore class is defined within the package java.util.concurrent and can be used to send signals between threads to avoid missed signals or to guard critical sections.

19. How to make a user thread to daemon thread?
There are two methods in the thread class that is used to make a user thread into a daemon thread. First, the setDaemon() method converts the user thread to the daemon thread and vice-versa. After this, the isDaemon() method is used, which returns a boolean true if the Thread is daemon. Else returns false if it is a non-daemon thread. 

20. Can you start a thread twice?
No, it's not at all possible to restart a thread once a thread gets started and completes its execution. Thread only runs once, and if you try to run it for a second time, then it will throw a runtime exception, i.e., Java. lang.IllegalThreadStateException. 

21. What are the tasks of the start() method?
The main task of the start() method is to register the Thread with the thread scheduler, so one can tell what child thread should perform, when, and how it will be scheduled that is handled by the thread scheduler. The second task is to call the corresponding run() method.

22. Explain the difference between class lock and object lock?
A class lock is present within the class and prevents simultaneous access to a concurrent static method or block. While object lock is related to the instance of a class that allows simultaneous access to concurrent methods or blocks in different objects.

23. Explain the difference between User thread and Daemon thread?
A user thread is also known as high priority thread. The Java virtual machine completes all the user threads before terminating. While the daemon thread is also known as low priority thread, and they are mainly used as background tasks and provide services to the user thread. 

24. What are the wait() and sleep() methods?
The wait() and sleep() methods are used to stop any running thread and convert them into a non-runnable state. The wait method is mostly used for thread sync, and the sleep() method is used to pause the running threads.

25. Explain the  difference between notify() and notifyAll()?
The notify() method is used to alert only one waiting thread among many waiting threads, while the notifyAll() method is used to send notifications to all the waiting threads. notify() method uses less memory and CPU in comparison to the notifyAll() method.

26. What do you mean by thread pool?
A thread pool can be considered a collection of all the threads that are ready to perform the tasks. It also increases the reusability of the threads as it does not create and destroy the threads each time.

27. Can two threads execute two methods (static and non-static concurrently)?
Yes, two threads can run two different methods (one static and one non-static) of the same class. However, it is important to note that unexpected behavior can occur because the locking mechanism will lock two different things: the object and the class itself, which means both methods will execute simultaneously, and a shared state can be mutated.

28. What is meant by volatile variables in Java?
In Java, the volatile keyword is used to declare a variable as volatile, which means changes made to it by one thread will be immediately visible to other threads. You can use this keyword to define simple flags or status indicators frequently checked by many threads.

29. What’s the purpose of the join() method?
The join() method in Java is provided by the Thread class and used for thread synchronization and coordination. This method allows you to make a thread wait for the completion of another thread. 

For example, there are two threads, A and B. If thread A calls the join() method on thread B, thread A will pause its execution and wait for thread B to complete.

30. How do synchronized methods and synchronized blocks differ, and which one is the preferred choice?
Synchronized methods and blocks in Java are used to achieve thread synchronization and prevent multiple threads from concurrently accessing critical code sections. The choice between synchronized methods and synchronized blocks depends on your specific requirements:

Synchronized Methods: Use synchronized methods when you want to synchronize the entire method and there's no need to synchronize different parts of the method separately.
 
Synchronized Blocks: Use synchronized blocks when you need more control over synchronization, and you want to synchronize specific sections of code. Synchronized blocks are more flexible and allow for finer-grained synchronization.
31. What is meant by deadlock and how it can occur?
A deadlock is a situation in which two or more threads are blocked for an infinite time, and they all wait for each other to release their resources. Deadlock can occur due to mutual exclusion, holding and waiting of threads or when a circular chain of two or more threads exists.

Frequently Asked Questions
Is it possible to call the run() method directly to start a new thread?
No, it's not possible at all. You need to call the start method to create a new thread otherwise it will execute in the current thread.

Can we Overload run() method?
Yes, it is possible to overload run() by passing parameters to it and also keeping a check over to comment down @override from the run() method. 

Why is multithreading required?
Multithreading is required in order to enhance the performance and to improve the responsiveness of the process.

Conclusion
In conclusion, multithreading is a crucial aspect of Java and modern software development, enhancing program efficiency and reducing resource usage. This article covered key multithreading interview questions and answers to help you succeed in your interviews.

