Object-oriented programming (OOP) is a programming paradigm that uses "objects" and their interactions to design applications and computer programs. Real-world examples of OOP concepts include objects such as a car, a person, and a bank account. These objects have properties (e.g. a car has a make, model, and color) and methods (e.g. a car can start, stop, and drive). OOP is used in many modern programming languages such as Java, C++, and Python to build robust and maintainable software.

Object Oriented Programming is based on Objects and not Classes.

Java Class and Objects
Java is an object-oriented programming language. The core concept of the object-oriented approach is to break complex problems into smaller objects.

An object is any entity that has a state and behavior. For example, a bicycle is an object. It has

States: idle, first gear, etc
Behaviors: braking, accelerating, etc.

Java Class
A class is a blueprint for the object. Before we create an object, we first need to define the class.

We can think of the class as a sketch (prototype) of a house. It contains all the details about the floors, doors, windows, etc. Based on these descriptions we build the house. House is the object.

Since many houses can be made from the same description, we can create many objects from a class.

Create a class in Java
We can create a class in Java using the class keyword. For example,

class ClassName {
  // fields
  // methods
}
Here, fields (variables) and methods represent the state and behavior of the object respectively.

fields are used to store data
methods are used to perform some operations
For our bicycle object, we can create the class as

class Bicycle {

  // state or field
  private int gear = 5;

  // behavior or method
  public void braking() {
    System.out.println("Working of Braking");
  }
}
In the above example, we have created a class named Bicycle. It contains a field named gear and a method named braking().

Here, Bicycle is a prototype. Now, we can create any number of bicycles using the prototype. And, all the bicycles will share the fields and methods of the prototype.

Note: We have used keywords private and public. These are known as access modifiers. To learn more, visit Java access modifiers.

Java Objects

An object is called an instance of a class. For example, suppose Bicycle is a class then MountainBicycle, SportsBicycle, TouringBicycle, etc can be considered as objects of the class.

Creating an Object in Java
Here is how we can create an object of a class.

className object = new className();

// for Bicycle class
Bicycle sportsBicycle = new Bicycle();

Bicycle touringBicycle = new Bicycle();
We have used the new keyword along with the constructor of the class to create an object. Constructors are similar to methods and have the same name as the class. For example, Bicycle() is the constructor of the Bicycle class. To learn more, visit Java Constructors.

Here, sportsBicycle and touringBicycle are the names of objects. We can use them to access fields and methods of the class.

As you can see, we have created two objects of the class. We can create multiple objects of a single class in Java.

Note: Fields and methods of a class are also called members of the class.

Access Members of a Class
We can use the name of objects along with the . operator to access members of a class. For example,

class Bicycle {

  // field of class
  int gear = 5;

  // method of class
  void braking() {
    ...
  }
}

// create object
Bicycle sportsBicycle = new Bicycle();

// access field and method
sportsBicycle.gear;
sportsBicycle.braking();
In the above example, we have created a class named Bicycle. It includes a field named gear and a method named braking(). Notice the statement,

Bicycle sportsBicycle = new Bicycle();
Here, we have created an object of Bicycle named sportsBicycle. We then use the object to access the field and method of the class.

sportsBicycle.gear - access the field gear
sportsBicycle.braking() - access the method braking()
We have mentioned the word method quite a few times. You will learn about Java methods in detail in the next chapter.

Now that we understand what is class and object. Let's see a fully working example.

Example: Java Class and Objects
class Lamp {
  
  // stores the value for light
  // true if light is on
  // false if light is off
  boolean isOn;

  // method to turn on the light
  void turnOn() {
    isOn = true;
    System.out.println("Light on? " + isOn);

  }

  // method to turnoff the light
  void turnOff() {
    isOn = false;
    System.out.println("Light on? " + isOn);
  }
}

class Main {
  public static void main(String[] args) {

    // create objects led and halogen
    Lamp led = new Lamp();
    Lamp halogen = new Lamp();

    // turn on the light by
    // calling method turnOn()
    led.turnOn();

    // turn off the light by
    // calling method turnOff()
    halogen.turnOff();
  }
}
Run Code
Output:

Light on? true
Light on? false
In the above program, we have created a class named Lamp. It contains a variable: isOn and two methods: turnOn() and turnOff().

Inside the Main class, we have created two objects: led and halogen of the Lamp class. We then used the objects to call the methods of the class.

led.turnOn() - It sets the isOn variable to true and prints the output.
halogen.turnOff() - It sets the isOn variable to false and prints the output.
The variable isOn defined inside the class is also called an instance variable. It is because when we create an object of the class, it is called an instance of the class. And, each instance will have its own copy of the variable.

That is, led and halogen objects will have their own copy of the isOn variable.

Example: Create objects inside the same class
Note that in the previous example, we have created objects inside another class and accessed the members from that class.

However, we can also create objects inside the same class.

class Lamp {
  
  // stores the value for light
  // true if light is on
  // false if light is off
  boolean isOn;

  // method to turn on the light
  void turnOn() {
    isOn = true;
    System.out.println("Light on? " + isOn);

  }

  public static void main(String[] args) {
    
    // create an object of Lamp
    Lamp led = new Lamp();

    // access method using object
    led.turnOn();
  }
}
Run Code
Output

Light on? true
Here, we are creating the object inside the main() method of the same class.

Java Methods
A method is a block of code that performs a specific task.

Suppose you need to create a program to create a circle and color it. You can create two methods to solve this problem:

a method to draw the circle
a method to color the circle
Dividing a complex problem into smaller chunks makes your program easy to understand and reusable.

In Java, there are two types of methods:

User-defined Methods: We can create our own method based on our requirements.
Standard Library Methods: These are built-in methods in Java that are available to use.
Let's first learn about user-defined methods.

Declaring a Java Method
The syntax to declare a method is:

returnType methodName() {
  // method body
}
Here,

returnType - It specifies what type of value a method returns For example if a method has an int return type then it returns an integer value.

If the method does not return a value, its return type is void.
methodName - It is an identifier that is used to refer to the particular method in a program.
method body - It includes the programming statements that are used to perform some tasks. The method body is enclosed inside the curly braces { }.
For example,

int addNumbers() {
// code
}
In the above example, the name of the method is adddNumbers(). And, the return type is int. We will learn more about return types later in this tutorial.

This is the simple syntax of declaring a method. However, the complete syntax of declaring a method is

modifier static returnType nameOfMethod (parameter1, parameter2, ...) {
  // method body
}
Here,

modifier - It defines access types whether the method is public, private, and so on. To learn more, visit Java Access Specifier.
static - If we use the static keyword, it can be accessed without creating objects.

For example, the sqrt() method of standard Math class is static. Hence, we can directly call Math.sqrt() without creating an instance of Math class.
parameter1/parameter2 - These are values passed to a method. We can pass any number of arguments to a method.
Calling a Method in Java
In the above example, we have declared a method named addNumbers(). Now, to use the method, we need to call it.

Here's is how we can call the addNumbers() method.

// calls the method
addNumbers();
Call a method in Java using the name the method followed by a parenthesis
Working of Java Method Call

Example 1: Java Methods
class Main {

  // create a method
  public int addNumbers(int a, int b) {
    int sum = a + b;
    // return value
    return sum;
  }

  public static void main(String[] args) {
    
    int num1 = 25;
    int num2 = 15;

    // create an object of Main
    Main obj = new Main();
    // calling method
    int result = obj.addNumbers(num1, num2);
    System.out.println("Sum is: " + result);
  }
}
Run Code
Output

Sum is: 40
In the above example, we have created a method named addNumbers(). The method takes two parameters a and b. Notice the line,

int result = obj.addNumbers(num1, num2);
Here, we have called the method by passing two arguments num1 and num2. Since the method is returning some value, we have stored the value in the result variable.

Note: The method is not static. Hence, we are calling the method using the object of the class.

Java Method Return Type
A Java method may or may not return a value to the function call. We use the return statement to return any value. For example,

int addNumbers() {
...
return sum;
}

Here, we are returning the variable sum. Since the return type of the function is int. The sum variable should be of int type. Otherwise, it will generate an error.

Example 2: Method Return Type
class Main {

// create a method
  public static int square(int num) {

    // return statement
    return num * num;
  }

  public static void main(String[] args) {
    int result;

    // call the method
    // store returned value to result
    result = square(10);

    System.out.println("Squared value of 10 is: " + result);
  }
}
Run Code
Output:

Squared value of 10 is: 100
In the above program, we have created a method named square(). The method takes a number as its parameter and returns the square of the number.

Here, we have mentioned the return type of the method as int. Hence, the method should always return an integer value.

Java method returns a value to the method call
Representation of the Java method returning a value
Note: If the method does not return any value, we use the void keyword as the return type of the method. For example,

public void square(int a) {
  int square = a * a;
  System.out.println("Square is: " + square);
}
Method Parameters in Java
A method parameter is a value accepted by the method. As mentioned earlier, a method can also have any number of parameters. For example,

// method with two parameters
int addNumbers(int a, int b) {
  // code
}

// method with no parameter
int addNumbers(){
  // code
}
If a method is created with parameters, we need to pass the corresponding values while calling the method. For example,

// calling the method with two parameters
addNumbers(25, 15);

// calling the method with no parameters
addNumbers()
Example 3: Method Parameters
class Main {

  // method with no parameter
  public void display1() {
    System.out.println("Method without parameter");
  }

  // method with single parameter
  public void display2(int a) {
    System.out.println("Method with a single parameter: " + a);
  }

  public static void main(String[] args) {
    
    // create an object of Main
    Main obj = new Main();

    // calling method with no parameter
    obj.display1();
    
    // calling method with the single parameter
    obj.display2(24);
  }
}
Run Code
Output

Method without parameter
Method with a single parameter: 24
Here, the parameter of the method is int. Hence, if we pass any other data type instead of int, the compiler will throw an error. It is because Java is a strongly typed language.

Note: The argument 24 passed to the display2() method during the method call is called the actual argument.

The parameter num accepted by the method definition is known as a formal argument. We need to specify the type of formal arguments. And, the type of actual arguments and formal arguments should always match.

Standard Library Methods
The standard library methods are built-in methods in Java that are readily available for use. These standard libraries come along with the Java Class Library (JCL) in a Java archive (*.jar) file with JVM and JRE.

For example,

print() is a method of java.io.PrintSteam. The print("...") method prints the string inside quotation marks.
sqrt() is a method of Math class. It returns the square root of a number.
Here's a working example:

Example 4: Java Standard Library Method
public class Main {
  public static void main(String[] args) {
    
    // using the sqrt() method
    System.out.print("Square root of 4 is: " + Math.sqrt(4));
  }
}
Run Code
Output:

Square root of 4 is: 2.0

What are the advantages of using methods?
1. The main advantage is code reusability. We can write a method once, and use it multiple times. We do not have to rewrite the entire code each time. Think of it as, "write once, reuse multiple times".

Example 5: Java Method for Code Reusability
public class Main {

  // method defined
  private static int getSquare(int x){
    return x * x;
  }

  public static void main(String[] args) {
    for (int i = 1; i <= 5; i++) {

      // method call
      int result = getSquare(i);
      System.out.println("Square of " + i + " is: " + result);
    }
  }
}
Run Code
Output:

Square of 1 is: 1
Square of 2 is: 4
Square of 3 is: 9
Square of 4 is: 16
Square of 5 is: 25
In the above program, we have created the method named getSquare() to calculate the square of a number. Here, the method is used to calculate the square of numbers less than 6.

Hence, the same method is used again and again.

2. Methods make code more readable and easier to debug. Here, the getSquare() method keeps the code to compute the square in a block. Hence, makes it more readable.


Java Method Overloading
In Java, two or more methods may have the same name if they differ in parameters (different number of parameters, different types of parameters, or both). These methods are called overloaded methods and this feature is called method overloading. For example:

void func() { ... }
void func(int a) { ... }
float func(double a) { ... }
float func(int a, float b) { ... }
Here, the func() method is overloaded. These methods have the same name but accept different arguments.

Note: The return types of the above methods are not the same. It is because method overloading is not associated with return types. Overloaded methods may have the same or different return types, but they must differ in parameters.

Why method overloading?
Suppose, you have to perform the addition of given numbers but there can be any number of arguments (let’s say either 2 or 3 arguments for simplicity).

In order to accomplish the task, you can create two methods sum2num(int, int) and sum3num(int, int, int) for two and three parameters respectively. However, other programmers, as well as you in the future may get confused as the behavior of both methods are the same but they differ by name.

The better way to accomplish this task is by overloading methods. And, depending upon the argument passed, one of the overloaded methods is called. This helps to increase the readability of the program.

How to perform method overloading in Java?
Here are different ways to perform method overloading:

1. Overloading by changing the number of parameters
class MethodOverloading {
    private static void display(int a){
        System.out.println("Arguments: " + a);
    }

    private static void display(int a, int b){
        System.out.println("Arguments: " + a + " and " + b);
    }

    public static void main(String[] args) {
        display(1);
        display(1, 4);
    }
}

Output:

Arguments: 1
Arguments: 1 and 4
2. Method Overloading by changing the data type of parameters
class MethodOverloading {

    // this method accepts int
    private static void display(int a){
        System.out.println("Got Integer data.");
    }

    // this method  accepts String object
    private static void display(String a){
        System.out.println("Got String object.");
    }

    public static void main(String[] args) {
        display(1);
        display("Hello");
    }
}
Output:

Got Integer data.
Got String object.
Here, both overloaded methods accept one argument. However, one accepts the argument of type int whereas other accepts String object.

Let’s look at a real-world example:

class HelperService {

    private String formatNumber(int value) {
        return String.format("%d", value);
    }

    private String formatNumber(double value) {
        return String.format("%.3f", value);
    }

    private String formatNumber(String value) {
        return String.format("%.2f", Double.parseDouble(value));
    }

    public static void main(String[] args) {
        HelperService hs = new HelperService();
        System.out.println(hs.formatNumber(500));
        System.out.println(hs.formatNumber(89.9934));
        System.out.println(hs.formatNumber("550"));
    }
}
When you run the program, the output will be:

500
89.993
550.00
Note: In Java, you can also overload constructors in a similar way like methods.

Recommended Reading: Java Constructor Overloading

Important Points
Two or more methods can have the same name inside the same class if they accept different arguments. This feature is known as method overloading.
Method overloading is achieved by either:
changing the number of arguments.
or changing the data type of arguments.
It is not method overloading if we only change the return type of methods. There must be differences in the number of parameters.

Java Constructors
A constructor in Java is similar to a method that is invoked when an object of the class is created.

Unlike Java methods, a constructor has the same name as that of the class and does not have any return type. For example,

class Test {
  Test() {
    // constructor body
  }
}
Here, Test() is a constructor. It has the same name as that of the class and doesn't have a return type.

Example: Java Constructor
class Main {
  private String name;

  // constructor
  Main() {
    System.out.println("Constructor Called:");
    name = "Programiz";
  }

  public static void main(String[] args) {

    // constructor is invoked while
    // creating an object of the Main class
    Main obj = new Main();
    System.out.println("The name is " + obj.name);
  }
}
Run Code
Output:

Constructor Called:
The name is Programiz
In the above example, we have created a constructor named Main().

Inside the constructor, we are initializing the value of the name variable.

Notice the statement creating an object of the Main class.

Main obj = new Main();
Here, when the object is created, the Main() constructor is called. And the value of the name variable is initialized.

Hence, the program prints the value of the name variables as Programiz.

Types of Constructor
In Java, constructors can be divided into three types:

No-Arg Constructor
Parameterized Constructor
Default Constructor
1. Java No-Arg Constructors
Similar to methods, a Java constructor may or may not have any parameters (arguments).

If a constructor does not accept any parameters, it is known as a no-argument constructor. For example,

private Constructor() {
   // body of the constructor
}
Example: Java Private No-arg Constructor
class Main {

  int i;

  // constructor with no parameter
  private Main() {
    i = 5;
    System.out.println("Constructor is called");
  }

  public static void main(String[] args) {

    // calling the constructor without any parameter
    Main obj = new Main();
    System.out.println("Value of i: " + obj.i);
  }
}
Run Code
Output:

Constructor is called
Value of i: 5
In the above example, we have created a constructor Main().

Here, the constructor does not accept any parameters. Hence, it is known as a no-arg constructor.

Notice that we have declared the constructor as private.

Once a constructor is declared private, it cannot be accessed from outside the class.

So, creating objects from outside the class is prohibited using the private constructor.

Here, we are creating the object inside the same class.

Hence, the program is able to access the constructor. To learn more, visit Java Implement Private Constructor.

However, if we want to create objects outside the class, then we need to declare the constructor as public.

Example: Java Public no-arg Constructors
class Company {
  String name;

  // public constructor
  public Company() {
    name = "Programiz";
  }
}

class Main {
  public static void main(String[] args) {

    // object is created in another class
    Company obj = new Company();
    System.out.println("Company name = " + obj.name);
  }
}
Run Code
Output

Company name = Programiz
2. Java Parameterized Constructor
A Java constructor can also accept one or more parameters. Such constructors are known as parameterized constructors (constructors with parameters).

Example: Parameterized Constructor
class Main {

  String languages;

  // constructor accepting single value
  Main(String lang) {
    languages = lang;
    System.out.println(languages + " Programming Language");
  }

  public static void main(String[] args) {

    // call constructor by passing a single value
    Main obj1 = new Main("Java");
    Main obj2 = new Main("Python");
    Main obj3 = new Main("C");
  }
}
Run Code
Output

Java Programming Language
Python Programming Language
C Programming Language
In the above example, we have created a constructor named Main().

Here, the constructor takes a single parameter. Notice the expression:

Main obj1 = new Main("Java");
Here, we are passing the single value to the constructor.

Based on the argument passed, the language variable is initialized inside the constructor.

3. Java Default Constructor
If we do not create any constructor, the Java compiler automatically creates a no-arg constructor during the execution of the program.

This constructor is called the default constructor.

Example: Default Constructor
class Main {

  int a;
  boolean b;

  public static void main(String[] args) {

    // calls default constructor
    Main obj = new Main();

    System.out.println("Default Value:");
    System.out.println("a = " + obj.a);
    System.out.println("b = " + obj.b);
  }
}
Run Code
Output

Default Value:
a = 0
b = false
Here, we haven't created any constructors.

Hence, the Java compiler automatically creates the default constructor.

The default constructor initializes any uninitialized instance variables with default values.

Type	Default Value
boolean	false
byte	0
short	0
int	0
long	0L
char	\u0000
float	0.0f
double	0.0d
object	Reference null
To learn more, visit Java Data Types.

In the above program, the variables a and b are initialized with default value 0 and false respectively.

The above program is equivalent to:

class Main {

  int a;
  boolean b;

   Main() {
    a = 0;
    b = false;
  }

  public static void main(String[] args) {
    // call the constructor
    Main obj = new Main();

    System.out.println("Default Value:");
    System.out.println("a = " + obj.a);
    System.out.println("b = " + obj.b);
  }
}
Run Code
Output

Default Value:
a = 0
b = false
Important Notes on Java Constructors
Constructors are invoked implicitly when you instantiate objects.
The two rules for creating a constructor are:
1. The name of the constructor should be the same as the class.
2. A Java constructor must not have a return type.
If a class doesn't have a constructor, the Java compiler automatically creates a default constructor during run-time. The default constructor initializes instance variables with default values. For example, the int variable will be initialized to 0
Constructor types:
No-Arg Constructor - a constructor that does not accept any arguments
Parameterized constructor - a constructor that accepts arguments
Default Constructor - a constructor that is automatically created by the Java compiler if it is not explicitly defined.
A constructor cannot be abstract or static or final.
A constructor can be overloaded but can not be overridden.
Constructors Overloading in Java
Similar to Java method overloading, we can also create two or more constructors with different parameters. This is called constructor overloading.

Example: Java Constructor Overloading
class Main {

  String language;

  // constructor with no parameter
  Main() {
    this.language = "Java";
  }

  // constructor with a single parameter
  Main(String language) {
    this.language = language;
  }

  public void getName() {
    System.out.println("Programming Language: " + this.language);
  }

  public static void main(String[] args) {

    // call constructor with no parameter
    Main obj1 = new Main();

    // call constructor with a single parameter
    Main obj2 = new Main("Python");

    obj1.getName();
    obj2.getName();
  }
}
Run Code
Output

Programming Language: Java
Programming Language: Python
In the above example, we have two constructors: Main() and Main(String language).

Here, both the constructors initialize the value of the variable language with different values.

Based on the parameter passed during object creation, different constructors are called, and different values are assigned.

It is also possible to call one constructor from another constructor. To learn more, visit Java Call One Constructor from Another.

Note: We have used this keyword to specify the variable of the class. To know more about this keyword, visit Java this keyword.

What is a static keyword in Java?
In Java, if we want to access class members, we must first create an instance of the class. But there will be situations where we want to access class members without creating any variables.

In those situations, we can use the static keyword in Java. If we want to access class members without creating an instance of the class, we need to declare the class members static.

The Math class in Java has almost all of its members static. So, we can access its members without creating instances of the Math class. For example,

public class Main {
    public static void main( String[] args ) {

        // accessing the methods of the Math class
        System.out.println("Absolute value of -12 =  " + Math.abs(-12));
        System.out.println("Value of PI = " + Math.PI);
        System.out.println("Value of E = " + Math.E);
        System.out.println("2^2 = " + Math.pow(2,2));
    }
}
Run Code
Output:

Absolute value of -12 = 12
Value of PI = 3.141592653589793
Value of E = 2.718281828459045
2^2 = 4.0
In the above example, we have not created any instances of the Math class. But we are able to access its methods: abs() and pow() and variables: PI and E.

It is possible because the methods and variables of the Math class are static.

Static Methods
Static methods are also called class methods. It is because a static method belongs to the class rather than the object of a class.

And we can invoke static methods directly using the class name. For example,

class Test {
    // static method inside the Test class
    public static void method() {...}
}

class Main {
    // invoking the static method
    Test.method();
}
Here, we can see that the static method can be accessed directly from other classes using the class name.

In every Java program, we have declared the main method static. It is because to run the program the JVM should be able to invoke the main method during the initial phase where no objects exist in the memory.

Example 1: Java static and non-static Methods
class StaticTest {

    // non-static method
    int multiply(int a, int b){
        return a * b;
    }

    // static method
    static int add(int a, int b){
        return a + b;
    }
}

public class Main {

   public static void main( String[] args ) {

        // create an instance of the StaticTest class
        StaticTest st = new StaticTest();

        // call the nonstatic method
        System.out.println(" 2 * 2 = " + st.multiply(2,2));

        // call the static method
        System.out.println(" 2 + 3 = " + StaticTest.add(2,3));
   }
}
Run Code
Output:

2 * 2 = 4
2 + 3 = 5
In the above program, we have declared a non-static method named multiply() and a static method named add() inside the class StaticTest.

Inside the Main class, we can see that we are calling the non-static method using the object of the class (st.multiply(2, 2)). However, we are calling the static method by using the class name (StaticTest.add(2, 3)).

In Java, when we create objects of a class, then every object will have its own copy of all the variables of the class. For example,

class Test {
    // regular variable
   int age;
}

class Main {
    // create instances of Test
    Test test1 = new Test();
    Test test2 = new Test();
}
Here, both the objects test1 and test2 will have separate copies of the variable age. And, they are different from each other.

However, if we declare a variable static, all objects of the class share the same static variable. It is because like static methods, static variables are also associated with the class. And, we don't need to create objects of the class to access the static variables. For example,

class Test {
    // static variable
    static int age;
}
class Main {
    // access the static variable
    Test.age = 20;
}
Here, we can see that we are accessing the static variable from the other class using the class name.

Example 2: Java static and non-static Variables
class Test {

   // static variable
   static int max = 10;
  
   // non-static variable
   int min = 5;
}

public class Main {
   public static void main(String[] args) {
       Test obj = new Test();

       // access the non-static variable
       System.out.println("min + 1 = " + (obj.min + 1));

       // access the static variable
       System.out.println("max + 1 = " + (Test.max + 1));
   }
}
Run Code
Output:

min + 1 = 6
max + 1 = 11
In the above program, we have declared a non-static variable named min and a static variable named max inside the class Test.

Inside the Main class, we can see that we are calling the non-static variable using the object of the class (obj.min + 1). However, we are calling the static variable by using the class name (Test.max + 1).

Note: Static variables are rarely used in Java. Instead, the static constants are used. These static constants are defined by static final keyword and represented in uppercase. This is why some people prefer to use uppercase for static variables as well.

Access static Variables and Methods within the Class
We are accessing the static variable from another class. Hence, we have used the class name to access it. However, if we want to access the static member from inside the class, it can be accessed directly. For example,

public class Main {

   // static variable
   static int age;
   // static method
   static void display() {
       System.out.println("Static Method");
   }
   public static void main(String[] args) {

       // access the static variable
       age = 30;
       System.out.println("Age is " + age);

       // access the static method
       display();
   }
}


Output:

Age is 30
Static Method
Here, we are able to access the static variable and method directly without using the class name. It is because static variables and methods are by default public. And, since we are accessing from the same class, we don't have to specify the class name.

Static Blocks
In Java, static blocks are used to initialize the static variables. For example,

class Test {
    // static variable
    static int age;

    // static block
    static {
        age = 23;
    }
}
Here we can see that we have used a static block with the syntax:

static {
    // variable initialization
}
The static block is executed only once when the class is loaded in memory. The class is loaded if either the object of the class is requested in code or the static members are requested in code.

A class can have multiple static blocks and each static block is executed in the same sequence in which they have been written in a program.

Example 3: Use of static block in java
class Main {

   // static variables
   static int a = 23;
   static int b;
   static int max;

   // static blocks
   static {
       System.out.println("First Static block.");
       b = a * 4;
   }
   static {
       System.out.println("Second Static block.");
       max = 30;
   }

   // static method
   static void display() {

       System.out.println("a = " + a);
       System.out.println("b = " + b);
       System.out.println("max = " + max);
   }

   public static void main(String args[]) {
       // calling the static method
       display();
   }
}
Run Code
Output:

First Static block.
Second Static block.
a = 23
b = 92
max = 30
In the above program. as soon as the Main class is loaded,

The value of a is set to 23.
The first static block is executed. Hence, the string First Static block is printed and the value of b is set to a * 4.
The second static block is executed. Hence, the string Second Static block is printed and the value of max is set to 30.
And finally, the print statements inside the method display() are executed.
Nested Static Class
In Java, we can declare a class inside another class. Such classes are known as nested classes. Nested classes are of 2 types:

Static Nested Classes
Non-static Nested Classes
For example,

class OuterClass {
    // static nested class
    static class NestedClass {...}

    // non-static nested class
    class InnerClass {...}
}

What are Access Modifiers?
In Java, access modifiers are used to set the accessibility (visibility) of classes, interfaces, variables, methods, constructors, data members, and the setter methods. For example,

class Animal {
    public void method1() {...}

   private void method2() {...}
}
In the above example, we have declared 2 methods: method1() and method2(). Here,

method1 is public - This means it can be accessed by other classes.
method2 is private - This means it can not be accessed by other classes.
Note the keyword public and private. These are access modifiers in Java. They are also known as visibility modifiers.

Note: You cannot set the access modifier of getters methods.

Types of Access Modifier
Before you learn about types of access modifiers, make sure you know about Java Packages.

There are four access modifiers keywords in Java and they are:

Modifier	Description
Default	declarations are visible only within the package (package private)
Private	declarations are visible within the class only
Protected	declarations are visible within the package or all subclasses
Public	declarations are visible everywhere
Default Access Modifier
If we do not explicitly specify any access modifier for classes, methods, variables, etc, then by default the default access modifier is considered. For example,

package defaultPackage;
class Logger {
    void message(){
        System.out.println("This is a message");
    }
}
Run Code
Here, the Logger class has the default access modifier. And the class is visible to all the classes that belong to the defaultPackage package. However, if we try to use the Logger class in another class outside of defaultPackage, we will get a compilation error.

Private Access Modifier
When variables and methods are declared private, they cannot be accessed outside of the class. For example,

class Data {
    // private variable
    private String name;
}

public class Main {
    public static void main(String[] main){

        // create an object of Data
        Data d = new Data();

        // access private variable and field from another class
        d.name = "Programiz";
    }
}
Run Code
In the above example, we have declared a private variable named name. When we run the program, we will get the following error:

Main.java:18: error: name has private access in Data
        d.name = "Programiz";
         ^

The error is generated because we are trying to access the private variable of the Data class from the Main class.

You might be wondering what if we need to access those private variables. In this case, we can use the getters and setters method. For example,

class Data {
    private String name;

    // getter method
    public String getName() {
        return this.name;
    }
    // setter method
    public void setName(String name) {
        this.name= name;
    }
}
public class Main {
    public static void main(String[] main){
        Data d = new Data();

        // access the private variable using the getter and setter
        d.setName("Programiz");
        System.out.println(d.getName());
    }
}
Run Code
Output:

The name is Programiz
In the above example, we have a private variable named name. In order to access the variable from the outer class, we have used methods: getName() and setName(). These methods are called getter and setter in Java.

Here, we have used the setter method (setName()) to assign value to the variable and the getter method (getName()) to access the variable.

We have used this keyword inside the setName() to refer to the variable of the class. To learn more on this keyword, visit Java this Keyword.

Note: We cannot declare classes and interfaces private in Java. However, the nested classes can be declared private. To learn more, visit Java Nested and Inner Class.

Protected Access Modifier
When methods and data members are declared protected, we can access them within the same package as well as from subclasses. For example,

class Animal {
    // protected method
    protected void display() {
        System.out.println("I am an animal");
    }
}

class Dog extends Animal {
    public static void main(String[] args) {

        // create an object of Dog class
        Dog dog = new Dog();
         // access protected method
        dog.display();
    }
}
Run Code
Output:

I am an animal
In the above example, we have a protected method named display() inside the Animal class. The Animal class is inherited by the Dog class. To learn more about inheritance, visit Java Inheritance.

We then created an object dog of the Dog class. Using the object we tried to access the protected method of the parent class.

Since protected methods can be accessed from the child classes, we are able to access the method of Animal class from the Dog class.

Note: We cannot declare classes or interfaces protected in Java.

Public Access Modifier
When methods, variables, classes, and so on are declared public, then we can access them from anywhere. The public access modifier has no scope restriction. For example,

// Animal.java file
// public class
public class Animal {
    // public variable
    public int legCount;

    // public method
    public void display() {
        System.out.println("I am an animal.");
        System.out.println("I have " + legCount + " legs.");
    }
}

// Main.java
public class Main {
    public static void main( String[] args ) {
        // accessing the public class
        Animal animal = new Animal();

        // accessing the public variable
        animal.legCount = 4;
        // accessing the public method
        animal.display();
    }
}
Run Code
Output:

I am an animal.
I have 4 legs.
Here,

The public class Animal is accessed from the Main class.
The public variable legCount is accessed from the Main class.
The public method display() is accessed from the Main class.

Access modifiers are mainly used for encapsulation. It can help us to control what part of a program can access the members of a class. So that misuse of data can be prevented. To learn more about encapsulation, visit Java Encapsulation.

In Java, this keyword is used to refer to the current object inside a method or a constructor. For example,

class Main {
    int instVar;

    Main(int instVar){
        this.instVar = instVar;
        System.out.println("this reference = " + this);
    }

    public static void main(String[] args) {
        Main obj = new Main(8);
        System.out.println("object reference = " + obj);
    }
}


Output:

this reference = Main@23fc625e
object reference = Main@23fc625e
In the above example, we created an object named obj of the class Main. We then print the reference to the object obj and this keyword of the class.

Here, we can see that the reference of both obj and this is the same. It means this is nothing but the reference to the current object.

Use of this Keyword
There are various situations where this keyword is commonly used.

1. Using this for Ambiguity Variable Names
In Java, it is not allowed to declare two or more variables having the same name inside a scope (class scope or method scope). However, instance variables and parameters may have the same name. For example,

class MyClass {
    // instance variable
    int age;

    // parameter
    MyClass(int age){
        age = age;
    }
}
In the above program, the instance variable and the parameter have the same name: age. Here, the Java compiler is confused due to name ambiguity.

In such a situation, we use this keyword. For example,

First, let's see an example without using this keyword:

class Main {

    int age;
    Main(int age){
        age = age;
    }

    public static void main(String[] args) {
        Main obj = new Main(8);
        System.out.println("obj.age = " + obj.age);
    }
}
Run Code
Output:

obj.age = 0
In the above example, we have passed 8 as a value to the constructor. However, we are getting 0 as an output. This is because the Java compiler gets confused because of the ambiguity in names between instance the variable and the parameter.

Now, let's rewrite the above code using this keyword.

class Main {

    int age;
    Main(int age){
        this.age = age;
    }

    public static void main(String[] args) {
        Main obj = new Main(8);
        System.out.println("obj.age = " + obj.age);
    }
}
Run Code
Output:

obj.age = 8

Now, we are getting the expected output. It is because when the constructor is called, this inside the constructor is replaced by the object obj that has called the constructor. Hence the age variable is assigned value 8.

Also, if the name of the parameter and instance variable is different, the compiler automatically appends this keyword. For example, the code:

class Main {
    int age;

    Main(int i) {
        age = i;
    }
}
is equivalent to:

class Main {
    int age;

    Main(int i) {
        this.age = i;
    }
}
2. this with Getters and Setters
Another common use of this keyword is in setters and getters methods of a class. For example:

class Main {
   String name;

   // setter method
   void setName( String name ) {
       this.name = name;
   }

   // getter method
   String getName(){
       return this.name;
   }

   public static void main( String[] args ) {
       Main obj = new Main();

       // calling the setter and the getter method
       obj.setName("Toshiba");
       System.out.println("obj.name: "+obj.getName());
   }
}
Run Code
Output:

obj.name: Toshiba
Here, we have used this keyword:

to assign value inside the setter method
to access value inside the getter method
3. Using this in Constructor Overloading
While working with constructor overloading, we might have to invoke one constructor from another constructor. In such a case, we cannot call the constructor explicitly. Instead, we have to use this keyword.

Here, we use a different form of this keyword. That is, this(). Let's take an example,

class Complex {

    private int a, b;

    // constructor with 2 parameters
    private Complex( int i, int j ){
        this.a = i;
        this.b = j;
    }

    // constructor with single parameter
    private Complex(int i){
        // invokes the constructor with 2 parameters
        this(i, i); 
    }

    // constructor with no parameter
    private Complex(){
        // invokes the constructor with single parameter
        this(0);
    }

    @Override
    public String toString(){
        return this.a + " + " + this.b + "i";
    }

    public static void main( String[] args ) {
  
        // creating object of Complex class
        // calls the constructor with 2 parameters
        Complex c1 = new Complex(2, 3); 
    
        // calls the constructor with a single parameter
        Complex c2 = new Complex(3);

        // calls the constructor with no parameters
        Complex c3 = new Complex();

        // print objects
        System.out.println(c1);
        System.out.println(c2);
        System.out.println(c3);
    }
}
Run Code
Output:

2 + 3i
3 + 3i
0 + 0i
In the above example, we have used this keyword,

to call the constructor Complex(int i, int j) from the constructor Complex(int i)
to call the constructor Complex(int i) from the constructor Complex()
Notice the line,

System.out.println(c1);
Here, when we print the object c1, the object is converted into a string. In this process, the toString() is called. Since we override the toString() method inside our class, we get the output according to that method.

One of the huge advantages of this() is to reduce the amount of duplicate code. However, we should be always careful while using this().

This is because calling constructor from another constructor adds overhead and it is a slow process. Another huge advantage of using this() is to reduce the amount of duplicate code.

Note: Invoking one constructor from another constructor is called explicit constructor invocation.

Passing this as an Argument
We can use this keyword to pass the current object as an argument to a method. For example,

class ThisExample {
    // declare variables
    int x;
    int y;

    ThisExample(int x, int y) {
       // assign values of variables inside constructor
        this.x = x;
        this.y = y;

        // value of x and y before calling add()
        System.out.println("Before passing this to addTwo() method:");
        System.out.println("x = " + this.x + ", y = " + this.y);

        // call the add() method passing this as argument
        add(this);

        // value of x and y after calling add()
        System.out.println("After passing this to addTwo() method:");
        System.out.println("x = " + this.x + ", y = " + this.y);
    }

    void add(ThisExample o){
        o.x += 2;
        o.y += 2;
    }
}

class Main {
    public static void main( String[] args ) {
        ThisExample obj = new ThisExample(1, -2);
    }
}
Run Code
Output:

Before passing this to addTwo() method:
x = 1, y = -2
After passing this to addTwo() method:
x = 3, y = 0
In the above example, inside the constructor ThisExample(), notice the line,

add(this);
Here, we are calling the add() method by passing this as an argument. Since this keyword contains the reference to the object obj of the class, we can change the value of x and y inside the add() method.

Java final keyword
In Java, the final keyword is used to denote constants. It can be used with variables, methods, and classes.

Once any entity (variable, method or class) is declared final, it can be assigned only once. That is,

the final variable cannot be reinitialized with another value
the final method cannot be overridden
the final class cannot be extended

1. Java final Variable
In Java, we cannot change the value of a final variable. For example,

class Main {
  public static void main(String[] args) {

    // create a final variable
    final int AGE = 32;

    // try to change the final variable
    AGE = 45;
    System.out.println("Age: " + AGE);
  }
}
Run Code
In the above program, we have created a final variable named age. And we have tried to change the value of the final variable.

When we run the program, we will get a compilation error with the following message.

cannot assign a value to final variable AGE
    AGE = 45;
    ^
Note: It is recommended to use uppercase to declare final variables in Java.

2. Java final Method
Before you learn about final methods and final classes, make sure you know about the Java Inheritance.

In Java, the final method cannot be overridden by the child class. For example,

class FinalDemo {
    // create a final method
    public final void display() {
      System.out.println("This is a final method.");
    }
}

class Main extends FinalDemo {
  // try to override final method
  public final void display() {
    System.out.println("The final method is overridden.");
  }

  public static void main(String[] args) {
    Main obj = new Main();
    obj.display();
  }
}
Run Code

In the above example, we have created a final method named display() inside the FinalDemo class. Here, the Main class inherits the FinalDemo class.

We have tried to override the final method in the Main class. When we run the program, we will get a compilation error with the following message.

 display() in Main cannot override display() in FinalDemo
  public final void display() {
                    ^
  overridden method is final
3. Java final Class
In Java, the final class cannot be inherited by another class. For example,

// create a final class
final class FinalClass {
  public void display() {
    System.out.println("This is a final method.");
  }
}

// try to extend the final class
class Main extends FinalClass {
  public  void display() {
    System.out.println("The final method is overridden.");
  }

  public static void main(String[] args) {
    Main obj = new Main();
    obj.display();
  }
}
Run Code
In the above example, we have created a final class named FinalClass. Here, we have tried to inherit the final class by the Main class.

When we run the program, we will get a compilation error with the following message.

cannot inherit from final FinalClass
class Main extends FinalClass {
}

Java instanceof Operator
The instanceof operator in Java is used to check whether an object is an instance of a particular class or not.

Its syntax is

objectName instanceOf className;
Here, if objectName is an instance of className, the operator returns true. Otherwise, it returns false.

Example: Java instanceof
class Main {

  public static void main(String[] args) {

    // create a variable of string type
    String name = "Programiz";
    
    // checks if name is instance of String
    boolean result1 = name instanceof String;
    System.out.println("name is an instance of String: " + result1);

    // create an object of Main
    Main obj = new Main();

    // checks if obj is an instance of Main
    boolean result2 = obj instanceof Main;
    System.out.println("obj is an instance of Main: " + result2);
  }
}
Run Code
Output

name is an instance of String: true
obj is an instance of Main: true
In the above example, we have created a variable name of the String type and an object obj of the Main class.

Here, we have used the instanceof operator to check whether name and obj are instances of the String and Main class respectively. And, the operator returns true in both cases.

Note: In Java, String is a class rather than a primitive data type. To learn more, visit Java String.

Java instanceof during Inheritance

We can use the instanceof operator to check if objects of the subclass is also an instance of the superclass. For example,

// Java Program to check if an object of the subclass
// is also an instance of the superclass

// superclass
class Animal {
}

// subclass
class Dog extends Animal {
}

class Main {
  public static void main(String[] args) {

    // create an object of the subclass
    Dog d1 = new Dog();

    // checks if d1 is an instance of the subclass
    System.out.println(d1 instanceof Dog);        // prints true

    // checks if d1 is an instance of the superclass
    System.out.println(d1 instanceof Animal);     // prints true
  }
}
Run Code
In the above example, we have created a subclass Dog that inherits from the superclass Animal. We have created an object d1 of the Dog class.

Inside the print statement, notice the expression,

d1 instanceof Animal
Here, we are using the instanceof operator to check whether d1 is also an instance of the superclass Animal.

Java instanceof in Interface
The instanceof operator is also used to check whether an object of a class is also an instance of the interface implemented by the class. For example,

// Java program to check if an object of a class is also
//  an instance of the interface implemented by the class

interface Animal {
}

class Dog implements Animal {
}

class Main {
  public static void main(String[] args) {

    // create an object of the Dog class
    Dog d1 = new Dog();

    // checks if the object of Dog
    // is also an instance of Animal
    System.out.println(d1 instanceof Animal);  // returns true
  }
}
Run Code
In the above example, the Dog class implements the Animal interface. Inside the print statement, notice the expression,

d1 instanceof Animal
Here, d1 is an instance of Dog class. The instanceof operator checks if d1 is also an instance of the interface Animal.

Note: In Java, all the classes are inherited from the Object class. So, instances of all the classes are also an instance of the Object class.

In the previous example, if we check,

d1 instanceof Object
The result will be true.

Java Inheritance
Inheritance is one of the key features of OOP that allows us to create a new class from an existing class.

The new class that is created is known as subclass (child or derived class) and the existing class from where the child class is derived is known as superclass (parent or base class).

The extends keyword is used to perform inheritance in Java. For example,

class Animal {
  // methods and fields
}

// use of extends keyword
// to perform inheritance
class Dog extends Animal {

  // methods and fields of Animal
  // methods and fields of Dog
}
In the above example, the Dog class is created by inheriting the methods and fields from the Animal class.

Here, Dog is the subclass and Animal is the superclass.

Example 1: Java Inheritance
class Animal {

  // field and method of the parent class
  String name;
  public void eat() {
    System.out.println("I can eat");
  }
}

// inherit from Animal
class Dog extends Animal {

  // new method in subclass
  public void display() {
    System.out.println("My name is " + name);
  }
}

class Main {
  public static void main(String[] args) {

    // create an object of the subclass
    Dog labrador = new Dog();

    // access field of superclass
    labrador.name = "Rohu";
    labrador.display();

    // call method of superclass
    // using object of subclass
    labrador.eat();

  }
}
Run Code
Output

My name is Rohu
I can eat
In the above example, we have derived a subclass Dog from superclass Animal. Notice the statements,

labrador.name = "Rohu";

labrador.eat();
Here, labrador is an object of Dog. However, name and eat() are the members of the Animal class.

Since Dog inherits the field and method from Animal, we are able to access the field and method using the object of the Dog.

Subclass Dog can access the field and method of the superclass Animal.
Java Inheritance Implementation
is-a relationship
In Java, inheritance is an is-a relationship. That is, we use inheritance only if there exists an is-a relationship between two classes. For example,

Car is a Vehicle
Orange is a Fruit
Surgeon is a Doctor
Dog is an Animal
Here, Car can inherit from Vehicle, Orange can inherit from Fruit, and so on.

Method Overriding in Java Inheritance
In Example 1, we see the object of the subclass can access the method of the superclass.


However, if the same method is present in both the superclass and subclass, what will happen?

In this case, the method in the subclass overrides the method in the superclass. This concept is known as method overriding in Java.

Example 2: Method overriding in Java Inheritance
class Animal {

  // method in the superclass
  public void eat() {
    System.out.println("I can eat");
  }
}

// Dog inherits Animal
class Dog extends Animal {

  // overriding the eat() method
  @Override
  public void eat() {
    System.out.println("I eat dog food");
  }

  // new method in subclass
  public void bark() {
    System.out.println("I can bark");
  }
}

class Main {
  public static void main(String[] args) {

    // create an object of the subclass
    Dog labrador = new Dog();

    // call the eat() method
    labrador.eat();
    labrador.bark();
  }
}
Run Code
Output

I eat dog food
I can bark
In the above example, the eat() method is present in both the superclass Animal and the subclass Dog.

Here, we have created an object labrador of Dog.

Now when we call eat() using the object labrador, the method inside Dog is called. This is because the method inside the derived class overrides the method inside the base class.

This is called method overriding. To learn more, visit Java Method Overriding.

Note: We have used the @Override annotation to tell the compiler that we are overriding a method. However, the annotation is not mandatory. To learn more, visit Java Annotations.

super Keyword in Java Inheritance
Previously we saw that the same method in the subclass overrides the method in superclass.

In such a situation, the super keyword is used to call the method of the parent class from the method of the child class.

Example 3: super Keyword in Inheritance
class Animal {

  // method in the superclass
  public void eat() {
    System.out.println("I can eat");
  }
}

// Dog inherits Animal
class Dog extends Animal {

  // overriding the eat() method
  @Override
  public void eat() {

    // call method of superclass
    super.eat();
    System.out.println("I eat dog food");
  }

  // new method in subclass
  public void bark() {
    System.out.println("I can bark");
  }
}

class Main {
  public static void main(String[] args) {

    // create an object of the subclass
    Dog labrador = new Dog();

    // call the eat() method
    labrador.eat();
    labrador.bark();
  }
}
Run Code
Output

I can eat
I eat dog food
I can bark 
In the above example, the eat() method is present in both the base class Animal and the derived class Dog. Notice the statement,

super.eat();
Here, the super keyword is used to call the eat() method present in the superclass.

We can also use the super keyword to call the constructor of the superclass from the constructor of the subclass. To learn more, visit Java super keyword.

protected Members in Inheritance
In Java, if a class includes protected fields and methods, then these fields and methods are accessible from the subclass of the class.

Example 4: protected Members in Inheritance
class Animal {
  protected String name;

  protected void display() {
    System.out.println("I am an animal.");
  }
}

class Dog extends Animal {

  public void getInfo() {
    System.out.println("My name is " + name);
  }
}

class Main {
  public static void main(String[] args) {

    // create an object of the subclass
    Dog labrador = new Dog();

    // access protected field and method
    // using the object of subclass
    labrador.name = "Rocky";
    labrador.display();

    labrador.getInfo();
  }
}
Run Code
Output

I am an animal.
My name is Rocky
In the above example, we have created a class named Animal. The class includes a protected field: name and a method: display().

We have inherited the Dog class inherits Animal. Notice the statement,

labrador.name = "Rocky";
labrador.display();
Here, we are able to access the protected field and method of the superclass using the labrador object of the subclass.

Why use inheritance?
The most important use of inheritance in Java is code reusability. The code that is present in the parent class can be directly used by the child class.
Method overriding is also known as runtime polymorphism. Hence, we can achieve Polymorphism in Java with the help of inheritance.
Types of inheritance
There are five types of inheritance.

1. Single Inheritance
In single inheritance, a single subclass extends from a single superclass. For example,

Class A inherits from class B.
Java Single Inheritance
2. Multilevel Inheritance
In multilevel inheritance, a subclass extends from a superclass and then the same subclass acts as a superclass for another class. For example,

Class B inherits from class A and class C inherits from class B.
Java Multilevel Inheritance
3. Hierarchical Inheritance
In hierarchical inheritance, multiple subclasses extend from a single superclass. For example,

Both classes B and C inherit from the single class A.
Java Hierarchical Inheritance
4. Multiple Inheritance
In multiple inheritance, a single subclass extends from multiple superclasses. For example,

Class C inherits from both classes A and B.
Java Multiple Inheritance
Note: Java doesn't support multiple inheritance. However, we can achieve multiple inheritance using interfaces. To learn more, visit Java implements multiple inheritance.

5. Hybrid Inheritance
Hybrid inheritance is a combination of two or more types of inheritance. For example,

Class B and C inherit from a single class A and class D inherits from both the class B and C.
Java Hybrid Inheritance
Here, we have combined hierarchical and multiple inheritance to form a hybrid inheritance.

Java Method Overriding
In the last tutorial, we learned about inheritance. Inheritance is an OOP property that allows us to derive a new class (subclass) from an existing class (superclass). The subclass inherits the attributes and methods of the superclass.

Now, if the same method is defined in both the superclass and the subclass, then the method of the subclass class overrides the method of the superclass. This is known as method overriding.

Example 1: Method Overriding
class Animal {
   public void displayInfo() {
      System.out.println("I am an animal.");
   }
}

class Dog extends Animal {
   @Override
   public void displayInfo() {
      System.out.println("I am a dog.");
   }
}

class Main {
   public static void main(String[] args) {
      Dog d1 = new Dog();
      d1.displayInfo();
   }
}
Run Code
Output:

I am a dog.
In the above program, the displayInfo() method is present in both the Animal superclass and the Dog subclass.

When we call displayInfo() using the d1 object (object of the subclass), the method inside the subclass Dog is called. The displayInfo() method of the subclass overrides the same method of the superclass.

Working of method overriding in Java.
Notice the use of the @Override annotation in our example. In Java, annotations are the metadata that we used to provide information to the compiler. Here, the @Override annotation specifies the compiler that the method after this annotation overrides the method of the superclass.

It is not mandatory to use @Override. However, when we use this, the method should follow all the rules of overriding. Otherwise, the compiler will generate an error.

Java Overriding Rules
Both the superclass and the subclass must have the same method name, the same return type and the same parameter list.
We cannot override the method declared as final and static.
We should always override abstract methods of the superclass (will be discussed in later tutorials).
super Keyword in Java Overriding
A common question that arises while performing overriding in Java is:

Can we access the method of the superclass after overriding?

Well, the answer is Yes. To access the method of the superclass from the subclass, we use the super keyword.

Example 2: Use of super Keyword
class Animal {
   public void displayInfo() {
      System.out.println("I am an animal.");
   }
}

class Dog extends Animal {
   public void displayInfo() {
      super.displayInfo();
      System.out.println("I am a dog.");
   }
}

class Main {
   public static void main(String[] args) {
      Dog d1 = new Dog();
      d1.displayInfo();
   }
}
Run Code
Output:

I am an animal.
I am a dog.

In the above example, the subclass Dog overrides the method displayInfo() of the superclass Animal.

When we call the method displayInfo() using the d1 object of the Dog subclass, the method inside the Dog subclass is called; the method inside the superclass is not called.

Inside displayInfo() of the Dog subclass, we have used super.displayInfo() to call displayInfo() of the superclass.

It is important to note that constructors in Java are not inherited. Hence, there is no such thing as constructor overriding in Java.

However, we can call the constructor of the superclass from its subclasses. For that, we use super(). To learn more, visit Java super keyword.

Access Specifiers in Method Overriding
The same method declared in the superclass and its subclasses can have different access specifiers. However, there is a restriction.

We can only use those access specifiers in subclasses that provide larger access than the access specifier of the superclass. For example,

Suppose, a method myClass() in the superclass is declared protected. Then, the same method myClass() in the subclass can be either public or protected, but not private.

Example 3: Access Specifier in Overriding
class Animal {
   protected void displayInfo() {
      System.out.println("I am an animal.");
   }
}

class Dog extends Animal {
   public void displayInfo() {
      System.out.println("I am a dog.");
   }
}

class Main {
   public static void main(String[] args) {
      Dog d1 = new Dog();
      d1.displayInfo();
   }
}
Run Code
Output:

I am a dog.
In the above example, the subclass Dog overrides the method displayInfo() of the superclass Animal.

Whenever we call displayInfo() using the d1 (object of the subclass), the method inside the subclass is called.

Notice that, the displayInfo() is declared protected in the Animal superclass. The same method has the public access specifier in the Dog subclass. This is possible because the public provides larger access than the protected.

Overriding Abstract Methods
In Java, abstract classes are created to be the superclass of other classes. And, if a class contains an abstract method, it is mandatory to override it.

Java super
The super keyword in Java is used in subclasses to access superclass members (attributes, constructors and methods).

Before we learn about the super keyword, make sure to know about Java inheritance.

Uses of super keyword
To call methods of the superclass that is overridden in the subclass.
To access attributes (fields) of the superclass if both superclass and subclass have attributes with the same name.
To explicitly call superclass no-arg (default) or parameterized constructor from the subclass constructor.
Let's understand each of these uses.

1. Access Overridden Methods of the superclass
If methods with the same name are defined in both superclass and subclass, the method in the subclass overrides the method in the superclass. This is called method overriding.

Example 1: Method overriding

class Animal {

  // overridden method
  public void display(){
    System.out.println("I am an animal");
  }
}

class Dog extends Animal {

  // overriding method
  @Override
  public void display(){
    System.out.println("I am a dog");
  }

  public void printMessage(){
    display();
  }
}

class Main {
  public static void main(String[] args) {
    Dog dog1 = new Dog();
    dog1.printMessage();
  }
}
Run Code
Output

I am a dog

In this example, by making an object dog1 of Dog class, we can call its method printMessage() which then executes the display() statement.

Since display() is defined in both the classes, the method of subclass Dog overrides the method of superclass Animal. Hence, the display() of the subclass is called

What if the overridden method of the superclass has to be called?

We use super.display() if the overridden method display() of superclass Animal needs to be called.

Example 2: super to Call Superclass Method
class Animal {

  // overridden method
  public void display(){
    System.out.println("I am an animal");
  }
}

class Dog extends Animal {

  // overriding method
  @Override
  public void display(){
    System.out.println("I am a dog");
  }

  public void printMessage(){

    // this calls overriding method
    display();

    // this calls overridden method
    super.display();
  }
}

class Main {
  public static void main(String[] args) {
    Dog dog1 = new Dog();
    dog1.printMessage();
  }
}
Run Code
Output

I am a dog
I am an animal
Here, how the above program works.

Working of super in Java
2. Access Attributes of the Superclass
The superclass and subclass can have attributes with the same name. We use the super keyword to access the attribute of the superclass.

Example 3: Access superclass attribute
class Animal {
  protected String type="animal";
}

class Dog extends Animal {
  public String type="mammal";

  public void printType() {
    System.out.println("I am a " + type);
    System.out.println("I am an " + super.type);
  }
}

class Main {
  public static void main(String[] args) {
    Dog dog1 = new Dog();
    dog1.printType();
  }
}
Run Code
Output:

I am a mammal
I am an animal

In this example, we have defined the same instance field type in both the superclass Animal and the subclass Dog.

We then created an object dog1 of the Dog class. Then, the printType() method is called using this object.

Inside the printType() function,

type refers to the attribute of the subclass Dog.
super.type refers to the attribute of the superclass Animal.
Hence, System.out.println("I am a " + type); prints I am a mammal. And, System.out.println("I am an " + super.type); prints I am an animal.

3. Use of super() to access superclass constructor
As we know, when an object of a class is created, its default constructor is automatically called.

To explicitly call the superclass constructor from the subclass constructor, we use super(). It's a special form of the super keyword.

super() can be used only inside the subclass constructor and must be the first statement.

Example 4: Use of super()
class Animal {

  // default or no-arg constructor of class Animal
  Animal() {
    System.out.println("I am an animal");
  }
}

class Dog extends Animal {

  // default or no-arg constructor of class Dog
  Dog() {

    // calling default constructor of the superclass
    super();

    System.out.println("I am a dog");
  }
}

class Main {
  public static void main(String[] args) {
    Dog dog1 = new Dog();
  }
}
Run Code
Output

I am an animal
I am a dog
Here, when an object dog1 of Dog class is created, it automatically calls the default or no-arg constructor of that class.

Inside the subclass constructor, the super() statement calls the constructor of the superclass and executes the statements inside it. Hence, we get the output I am an animal.

Working of super() in Java
The flow of the program then returns back to the subclass constructor and executes the remaining statements. Thus, I am a dog will be printed.

However, using super() is not compulsory. Even if super() is not used in the subclass constructor, the compiler implicitly calls the default constructor of the superclass.

So, why use redundant code if the compiler automatically invokes super()?

It is required if the parameterized constructor (a constructor that takes arguments) of the superclass has to be called from the subclass constructor.

The parameterized super() must always be the first statement in the body of the constructor of the subclass, otherwise, we get a compilation error.

Example 5: Call Parameterized Constructor Using super()
class Animal {

  // default or no-arg constructor
  Animal() {
    System.out.println("I am an animal");
  }

  // parameterized constructor
  Animal(String type) {
    System.out.println("Type: "+type);
  }
}

class Dog extends Animal {

  // default constructor
  Dog() {

    // calling parameterized constructor of the superclass
    super("Animal");

    System.out.println("I am a dog");
  }
}

class Main {
  public static void main(String[] args) {
    Dog dog1 = new Dog();
  }
}
Run Code
Output

Type: Animal
I am a dog
The compiler can automatically call the no-arg constructor. However, it cannot call parameterized constructors.

If a parameterized constructor has to be called, we need to explicitly define it in the subclass constructor.

Working of super in case of parameterized constructor.
Note that in the above example, we explicitly called the parameterized constructor super("Animal"). The compiler does not call the default constructor of the superclass in this case.

Java Abstract Class and Abstract Methods
Java Abstract Class
The abstract class in Java cannot be instantiated (we cannot create objects of abstract classes). We use the abstract keyword to declare an abstract class. For example,

// create an abstract class
abstract class Language {
  // fields and methods
}
...

// try to create an object Language
// throws an error
Language obj = new Language(); 
An abstract class can have both the regular methods and abstract methods. For example,

abstract class Language {

  // abstract method
  abstract void method1();

  // regular method
  void method2() {
    System.out.println("This is regular method");
  }
}
To know about the non-abstract methods, visit Java methods. Here, we will learn about abstract methods.

Java Abstract Method
A method that doesn't have its body is known as an abstract method. We use the same abstract keyword to create abstract methods. For example,

abstract void display();
Here, display() is an abstract method. The body of display() is replaced by ;.

If a class contains an abstract method, then the class should be declared abstract. Otherwise, it will generate an error. For example,

// error
// class should be abstract
class Language {

  // abstract method
  abstract void method1();
}
Example: Java Abstract Class and Method
Though abstract classes cannot be instantiated, we can create subclasses from it. We can then access members of the abstract class using the object of the subclass. For example,

abstract class Language {

  // method of abstract class
  public void display() {
    System.out.println("This is Java Programming");
  }
}

class Main extends Language {

  public static void main(String[] args) {
    
    // create an object of Main
    Main obj = new Main();

    // access method of abstract class
    // using object of Main class
    obj.display();
  }
}
Run Code
Output

This is Java programming
In the above example, we have created an abstract class named Language. The class contains a regular method display().

We have created the Main class that inherits the abstract class. Notice the statement,

obj.display();
Here, obj is the object of the child class Main. We are calling the method of the abstract class using the object obj.

Implementing Abstract Methods
If the abstract class includes any abstract method, then all the child classes inherited from the abstract superclass must provide the implementation of the abstract method. For example,

abstract class Animal {
  abstract void makeSound();

  public void eat() {
    System.out.println("I can eat.");
  }
}

class Dog extends Animal {

  // provide implementation of abstract method
  public void makeSound() {
    System.out.println("Bark bark");
  }
}

class Main {
  public static void main(String[] args) {

    // create an object of Dog class
    Dog d1 = new Dog();

    d1.makeSound();
    d1.eat();
  }
}
Run Code
Output

Bark bark
I can eat.

In the above example, we have created an abstract class Animal. The class contains an abstract method makeSound() and a non-abstract method eat().

We have inherited a subclass Dog from the superclass Animal. Here, the subclass Dog provides the implementation for the abstract method makeSound().

We then used the object d1 of the Dog class to call methods makeSound() and eat().

Note: If the Dog class doesn't provide the implementation of the abstract method makeSound(), Dog should also be declared as abstract. This is because the subclass Dog inherits makeSound() from Animal.

Accesses Constructor of Abstract Classes
An abstract class can have constructors like the regular class. And, we can access the constructor of an abstract class from the subclass using the super keyword. For example,

abstract class Animal {
   Animal() {
      ….
   }
}

class Dog extends Animal {
   Dog() {
      super();
      ...
   }
}
Here, we have used the super() inside the constructor of Dog to access the constructor of the Animal.

Note that the super should always be the first statement of the subclass constructor. Visit Java super keyword to learn more.

Java Abstraction
The major use of abstract classes and methods is to achieve abstraction in Java.

Abstraction is an important concept of object-oriented programming that allows us to hide unnecessary details and only show the needed information.

This allows us to manage complexity by omitting or hiding details with a simpler, higher-level idea.

A practical example of abstraction can be motorbike brakes. We know what brake does. When we apply the brake, the motorbike will stop. However, the working of the brake is kept hidden from us.

The major advantage of hiding the working of the brake is that now the manufacturer can implement brake differently for different motorbikes, however, what brake does will be the same.

Let's take an example that helps us to better understand Java abstraction.

Example 3: Java Abstraction
abstract class MotorBike {
  abstract void brake();
}

class SportsBike extends MotorBike {
    
  // implementation of abstract method
  public void brake() {
    System.out.println("SportsBike Brake");
  }
}

class MountainBike extends MotorBike {
    
  // implementation of abstract method
  public void brake() {
    System.out.println("MountainBike Brake");
  }
}

class Main {
  public static void main(String[] args) {
    MountainBike m1 = new MountainBike();
    m1.brake();
    SportsBike s1 = new SportsBike();
    s1.brake();
  }
}
Run Code
Output:

MountainBike Brake
SportsBike Brake
In the above example, we have created an abstract super class MotorBike. The superclass MotorBike has an abstract method brake().

The brake() method cannot be implemented inside MotorBike. It is because every bike has different implementation of brakes. So, all the subclasses of MotorBike would have different implementation of brake().

So, the implementation of brake() in MotorBike is kept hidden.

Here, MountainBike makes its own implementation of brake() and SportsBike makes its own implementation of brake().

Note: We can also use interfaces to achieve abstraction in Java. To learn more, visit Java Interface.

Key Points to Remember
We use the abstract keyword to create abstract classes and methods.
An abstract method doesn't have any implementation (method body).
A class containing abstract methods should also be abstract.
We cannot create objects of an abstract class.
To implement features of an abstract class, we inherit subclasses from it and create objects of the subclass.
A subclass must override all abstract methods of an abstract class. However, if the subclass is declared abstract, it's not mandatory to override abstract methods.
We can access the static attributes and methods of an abstract class using the reference of the abstract class. For example,
Animal.staticMethod();


Java Interface
An interface is a fully abstract class. It includes a group of abstract methods (methods without a body).

We use the interface keyword to create an interface in Java. For example,

interface Language {
  public void getType();

  public void getVersion();
}
Here,

Language is an interface.
It includes abstract methods: getType() and getVersion().
Implementing an Interface
Like abstract classes, we cannot create objects of interfaces.

To use an interface, other classes must implement it. We use the implements keyword to implement an interface.

Example 1: Java Interface
interface Polygon {
  void getArea(int length, int breadth);
}

// implement the Polygon interface
class Rectangle implements Polygon {

  // implementation of abstract method
  public void getArea(int length, int breadth) {
    System.out.println("The area of the rectangle is " + (length * breadth));
  }
}

class Main {
  public static void main(String[] args) {
    Rectangle r1 = new Rectangle();
    r1.getArea(5, 6);
  }
}
Run Code
Output

The area of the rectangle is 30
In the above example, we have created an interface named Polygon. The interface contains an abstract method getArea().

Here, the Rectangle class implements Polygon. And, provides the implementation of the getArea() method.

Example 2: Java Interface
// create an interface
interface Language {
  void getName(String name);
}

// class implements interface
class ProgrammingLanguage implements Language {

  // implementation of abstract method
  public void getName(String name) {
    System.out.println("Programming Language: " + name);
  }
}

class Main {
  public static void main(String[] args) {
    ProgrammingLanguage language = new ProgrammingLanguage();
    language.getName("Java");
  }
}
Run Code
Output

Programming Language: Java
In the above example, we have created an interface named Language. The interface includes an abstract method getName().

Here, the ProgrammingLanguage class implements the interface and provides the implementation for the method.

Implementing Multiple Interfaces
In Java, a class can also implement multiple interfaces. For example,

interface A {
  // members of A
}

interface B {
  // members of B
}

class C implements A, B {
  // abstract members of A
  // abstract members of B
}
Extending an Interface
Similar to classes, interfaces can extend other interfaces. The extends keyword is used for extending interfaces. For example,

interface Line {
  // members of Line interface
}

// extending interface
interface Polygon extends Line {
  // members of Polygon interface
  // members of Line interface
}

Here, the Polygon interface extends the Line interface. Now, if any class implements Polygon, it should provide implementations for all the abstract methods of both Line and Polygon.

Extending Multiple Interfaces
An interface can extend multiple interfaces. For example,

interface A {
   ...
}
interface B {
   ... 
}

interface C extends A, B {
   ...
}
Advantages of Interface in Java
Now that we know what interfaces are, let's learn about why interfaces are used in Java.

Similar to abstract classes, interfaces help us to achieve abstraction in Java.

Here, we know getArea() calculates the area of polygons, but the way area is calculated is different for different polygons. Hence, the implementation of getArea() is independent of one another.
Interfaces provide specifications that a class (which implements it) must follow.

In our previous example, we used getArea() as a specification inside the interface Polygon. This is like setting a rule that we should be able to get the area of every polygon.

Now any class that implements the Polygon interface must provide an implementation for the getArea() method.
Interfaces are also used to achieve multiple inheritance in Java. For example,
interface Line {
…
}

interface Polygon {
…
}

class Rectangle implements Line, Polygon {
…
}



Here, the class Rectangle is implementing two different interfaces. This is how we achieve multiple inheritance in Java.
Note: All the methods inside an interface are implicitly public and all fields are implicitly public static final. For example,

interface Language {
  
  // by default public static final
  String type = "programming language";

  // by default public
  void getName();
}
default methods in Java Interfaces
With the release of Java 8, we can now add methods with implementation inside an interface. These methods are called default methods.

To declare default methods inside interfaces, we use the default keyword. For example,

public default void getSides() {
   // body of getSides()
}
Why default methods?
Let's take a scenario to understand why default methods are introduced in Java.

Suppose, we need to add a new method in an interface.

We can add the method in our interface easily without implementation. However, that's not the end of the story. All our classes that implement that interface must provide an implementation for the method.

If a large number of classes were implementing this interface, we need to track all these classes and make changes to them. This is not only tedious but error-prone as well.

To resolve this, Java introduced default methods. Default methods are inherited like ordinary methods.

Let's take an example to have a better understanding of default methods.

Example: Default Method in Java Interface
interface Polygon {
  void getArea();

  // default method 
  default void getSides() {
    System.out.println("I can get sides of a polygon.");
  }
}

// implements the interface
class Rectangle implements Polygon {
  public void getArea() {
    int length = 6;
    int breadth = 5;
    int area = length * breadth;
    System.out.println("The area of the rectangle is " + area);
  }

  // overrides the getSides()
  public void getSides() {
    System.out.println("I have 4 sides.");
  }
}

// implements the interface
class Square implements Polygon {
  public void getArea() {
    int length = 5;
    int area = length * length;
    System.out.println("The area of the square is " + area);
  }
}

class Main {
  public static void main(String[] args) {

    // create an object of Rectangle
    Rectangle r1 = new Rectangle();
    r1.getArea();
    r1.getSides();

    // create an object of Square
    Square s1 = new Square();
    s1.getArea();
    s1.getSides();
  }
}
Run Code
Output

The area of the rectangle is 30
I have 4 sides.
The area of the square is 25
I can get sides of a polygon.
In the above example, we have created an interface named Polygon. It has a default method getSides() and an abstract method getArea().

Here, we have created two classes, Rectangle and Square, that implement Polygon.

The Rectangle class provides the implementation of the getArea() method and overrides the getSides() method. However, the Square class only provides the implementation of the getArea() method.

Now, while calling the getSides() method using the Rectangle object, the overridden method is called. However, in the case of the Square object, the default method is called.

private and static Methods in Interface
The Java 8 also added another feature to include static methods inside an interface.

Similar to a class, we can access static methods of an interface using its references. For example,

// create an interface
interface Polygon {
  staticMethod(){..}
}

// access static method
Polygon.staticMethod();
Note: With the release of Java 9, private methods are also supported in interfaces.

We cannot create objects of an interface. Hence, private methods are used as helper methods that provide support to other methods in interfaces.

Practical Example of Interface
Let's see a more practical example of Java Interface.

// To use the sqrt function
import java.lang.Math;

interface  Polygon {
   void getArea();
  
 // calculate the perimeter of a Polygon
   default void getPerimeter(int... sides) {
      int perimeter = 0;
      for (int side: sides) {
         perimeter += side;
      }

   System.out.println("Perimeter: " + perimeter);
   }
}

class Triangle implements Polygon {
   private int a, b, c;
   private double s, area;

// initializing sides of a triangle
   Triangle(int a, int b, int c) {
      this.a = a;
      this.b = b;
      this.c = c;
      s = 0;
   }

// calculate the area of a triangle
   public void getArea() {
      s = (double) (a + b + c)/2;
      area = Math.sqrt(s*(s-a)*(s-b)*(s-c));
      System.out.println("Area: " + area);
   }
}

class Main {
   public static void main(String[] args) {
      Triangle t1 = new Triangle(2, 3, 4);

// calls the method of the Triangle class
      t1.getArea();

// calls the method of Polygon
      t1.getPerimeter(2, 3, 4);
   }
}
Run Code
Output

Area: 2.9047375096555625
Perimeter: 9
In the above program, we have created an interface named Polygon. It includes a default method getPerimeter() and an abstract method getArea().

We can calculate the perimeter of all polygons in the same manner so we implemented the body of getPerimeter() in Polygon.

Now, all polygons that implement Polygon can use getPerimeter() to calculate perimeter.

However, the rule for calculating the area is different for different polygons. Hence, getArea() is included without implementation.

Any class that implements Polygon must provide an implementation of getArea().


Java Polymorphism
Polymorphism is an important concept of object-oriented programming. It simply means more than one form.

That is, the same entity (method or operator or object) can perform different operations in different scenarios.

Example: Java Polymorphism
class Polygon {

  // method to render a shape
  public void render() {
    System.out.println("Rendering Polygon...");
  }
}

class Square extends Polygon {

  // renders Square
  public void render() {
    System.out.println("Rendering Square...");
  }
}

class Circle extends Polygon {

  // renders circle
  public void render() {
    System.out.println("Rendering Circle...");
  }
}

class Main {
  public static void main(String[] args) {
    
    // create an object of Square
    Square s1 = new Square();
    s1.render();

    // create an object of Circle
    Circle c1 = new Circle();
    c1.render();
  }
}
Run Code
Output

Rendering Square...
Rendering Circle...
In the above example, we have created a superclass: Polygon and two subclasses: Square and Circle. Notice the use of the render() method.

The main purpose of the render() method is to render the shape. However, the process of rendering a square is different than the process of rendering a circle.

Hence, the render() method behaves differently in different classes. Or, we can say render() is polymorphic.

Why Polymorphism?
Polymorphism allows us to create consistent code. In the previous example, we can also create different methods: renderSquare() and renderCircle() to render Square and Circle, respectively.

This will work perfectly. However, for every shape, we need to create different methods. It will make our code inconsistent.

To solve this, polymorphism in Java allows us to create a single method render() that will behave differently for different shapes.

Note: The print() method is also an example of polymorphism. It is used to print values of different types like char, int, string, etc.

We can achieve polymorphism in Java using the following ways:

Method Overriding
Method Overloading
Operator Overloading
1. Java Method Overriding
During inheritance in Java, if the same method is present in both the superclass and the subclass. Then, the method in the subclass overrides the same method in the superclass. This is called method overriding.

In this case, the same method will perform one operation in the superclass and another operation in the subclass. For example,

Example 1: Polymorphism using method overriding
class Language {
  public void displayInfo() {
    System.out.println("Common English Language");
  }
}

class Java extends Language {
  @Override
  public void displayInfo() {
    System.out.println("Java Programming Language");
  }
}

class Main {
  public static void main(String[] args) {

    // create an object of Java class
    Java j1 = new Java();
    j1.displayInfo();

    // create an object of Language class
    Language l1 = new Language();
    l1.displayInfo();
  }
}
Run Code
Output:

Java Programming Language
Common English Language

In the above example, we have created a superclass named Language and a subclass named Java. Here, the method displayInfo() is present in both Language and Java.

The use of displayInfo() is to print the information. However, it is printing different information in Language and Java.

Based on the object used to call the method, the corresponding information is printed.

displayInfo() method prints Common English Language when called using l1 object and when using j1 object, it prints Java Programming Language
Working of Java Polymorphism
Note: The method that is called is determined during the execution of the program. Hence, method overriding is a run-time polymorphism.

2. Java Method Overloading
In a Java class, we can create methods with the same name if they differ in parameters. For example,

void func() { ... }
void func(int a) { ... }
float func(double a) { ... }
float func(int a, float b) { ... }
This is known as method overloading in Java. Here, the same method will perform different operations based on the parameter.

Example 3: Polymorphism using method overloading
class Pattern {

  // method without parameter
  public void display() {
    for (int i = 0; i < 10; i++) {
      System.out.print("*");
    }
  }

  // method with single parameter
  public void display(char symbol) {
    for (int i = 0; i < 10; i++) {
      System.out.print(symbol);
    }
  }
}

class Main {
  public static void main(String[] args) {
    Pattern d1 = new Pattern();

    // call method without any argument
    d1.display();
    System.out.println("\n");

    // call method with a single argument
    d1.display('#');
  }
}
Run Code
Output:

**********

##########
In the above example, we have created a class named Pattern. The class contains a method named display() that is overloaded.

// method with no arguments
display() {...}

// method with a single char type argument
display(char symbol) {...}
Here, the main function of display() is to print the pattern. However, based on the arguments passed, the method is performing different operations:

prints a pattern of *, if no argument is passed or
prints pattern of the parameter, if a single char type argument is passed.
Note: The method that is called is determined by the compiler. Hence, it is also known as compile-time polymorphism.

3. Java Operator Overloading
Some operators in Java behave differently with different operands. For example,

+ operator is overloaded to perform numeric addition as well as string concatenation, and
operators like &, |, and ! are overloaded for logical and bitwise operations.
Let's see how we can achieve polymorphism using operator overloading.

The + operator is used to add two entities. However, in Java, the + operator performs two operations.

1. When + is used with numbers (integers and floating-point numbers), it performs mathematical addition. For example,

int a = 5;
int b = 6;

// + with numbers
int sum = a + b;  // Output = 11
2. When we use the + operator with strings, it will perform string concatenation (join two strings). For example,

String first = "Java ";
String second = "Programming";

// + with strings
name = first + second;  // Output = Java Programming
Here, we can see that the + operator is overloaded in Java to perform two operations: addition and concatenation.

Note: In languages like C++, we can define operators to work differently for different operands. However, Java doesn't support user-defined operator overloading.

Polymorphic Variables
A variable is called polymorphic if it refers to different values under different conditions.

Object variables (instance variables) represent the behavior of polymorphic variables in Java. It is because object variables of a class can refer to objects of its class as well as objects of its subclasses.

Example: Polymorphic Variables
class ProgrammingLanguage {
  public void display() {
    System.out.println("I am Programming Language.");
  }
}

class Java extends ProgrammingLanguage {
  @Override
  public void display() {
    System.out.println("I am Object-Oriented Programming Language.");
  }
}

class Main {
  public static void main(String[] args) {

    // declare an object variable
    ProgrammingLanguage pl;

    // create object of ProgrammingLanguage
    pl = new ProgrammingLanguage();
    pl.display();

    // create object of Java class
    pl = new Java();
    pl.display();
  }
}
Run Code
Output:

I am Programming Language.
I am Object-Oriented Programming Language.
In the above example, we have created an object variable pl of the ProgrammingLanguage class. Here, pl is a polymorphic variable. This is because,

In statement pl = new ProgrammingLanguage(), pl refer to the object of the ProgrammingLanguage class.
And, in statement pl = new Java(), pl refer to the object of the Java class.

Java Encapsulation
Java Encapsulation
Encapsulation is one of the key features of object-oriented programming. Encapsulation refers to the bundling of fields and methods inside a single class.

It prevents outer classes from accessing and changing fields and methods of a class. This also helps to achieve data hiding.

Example 1: Java Encapsulation
class Area {

  // fields to calculate area
  int length;
  int breadth;

  // constructor to initialize values
  Area(int length, int breadth) {
    this.length = length;
    this.breadth = breadth;
  }

  // method to calculate area
  public void getArea() {
    int area = length * breadth;
    System.out.println("Area: " + area);
  }
}

class Main {
  public static void main(String[] args) {

    // create object of Area
    // pass value of length and breadth
    Area rectangle = new Area(5, 6);
    rectangle.getArea();
  }
}
Run Code
Output

Area: 30
In the above example, we have created a class named Area. The main purpose of this class is to calculate the area.

To calculate an area, we need two variables: length and breadth and a method: getArea(). Hence, we bundled these fields and methods inside a single class.

Here, the fields and methods can be accessed from other classes as well. Hence, this is not data hiding.

This is only encapsulation. We are just keeping similar codes together.

Note: People often consider encapsulation as data hiding, but that's not entirely true.

Encapsulation refers to the bundling of related fields and methods together. This can be used to achieve data hiding. Encapsulation in itself is not data hiding.

Why Encapsulation?
In Java, encapsulation helps us to keep related fields and methods together, which makes our code cleaner and easy to read.
It helps to control the values of our data fields. For example,
class Person {
  private int age;

  public void setAge(int age) {
    if (age >= 0) {
      this.age = age;
    }
  }
}


Here, we are making the age variable private and applying logic inside the setAge() method. Now, age cannot be negative.
The getter and setter methods provide read-only or write-only access to our class fields. For example,
getName()  // provides read-only access
setName() // provides write-only access
It helps to decouple components of a system. For example, we can encapsulate code into multiple bundles.

These decoupled components (bundle) can be developed, tested, and debugged independently and concurrently. And, any changes in a particular component do not have any effect on other components.
We can also achieve data hiding using encapsulation. In the above example, if we change the length and breadth variable into private, then the access to these fields is restricted.

And, they are kept hidden from outer classes. This is called data hiding.
Data Hiding

Data hiding is a way of restricting the access of our data members by hiding the implementation details. Encapsulation also provides a way for data hiding.

We can use access modifiers to achieve data hiding. For example,

Example 2: Data hiding using the private specifier
class Person {

  // private field
  private int age;

  // getter method
  public int getAge() {
    return age;
  }

  // setter method
  public void setAge(int age) {
    this.age = age;
  }
}

class Main {
  public static void main(String[] args) {

    // create an object of Person
    Person p1 = new Person();

    // change age using setter
    p1.setAge(24);

    // access age using getter
    System.out.println("My age is " + p1.getAge());
  }
}
Run Code
Output

My age is 24
In the above example, we have a private field age. Since it is private, it cannot be accessed from outside the class.

In order to access age, we have used public methods: getAge() and setAge(). These methods are called getter and setter methods.

Making age private allowed us to restrict unauthorized access from outside the class. This is data hiding.

If we try to access the age field from the Main class, we will get an error.

// error: age has private access in Person
p1.age = 24;















Example 2:
Let’s say you have the blueprint of your future house over a hilltop ⛰️

Class: BluePrint
Object: House
Data: People living in the house

Important Points:
No memory is allocated when a class is created. Memory is allocated only when an object is created, i.e., when an instance of a class is created.
1. Parent Class: A class that an object shares all the properties off. (base class or superclass class)
2. Class: A particular type of class that does have objects.
3. Sub Class: A particular type of class that has a parent class. (derived class, extended class, or child class)

OBJECT:
Class: Animal
Object: Cat, Dog, Lion

Each object has its own identity, attribute, and behavior.
Consider both class and object. When we consider an actual laptop, the factory or the mechanical system that manufactures the laptop is the class and the laptop produced is it’s object

ENCAPSULATION (Information Hiding)
State (Private variables)
Methods (Behaviour)

Example 1:
Class: Person
Data Member: “socialSecurityNumber” (private)

A method called “bankTransaction()” is implemented, that function might then access the “socialSecurityNumber” variable.

Such a class would effectively encapsulate a person’s personal information.

Example 2:
class Encapsulation{
private:
    int x;
public:
    void set(int a){
        x =a;
    }
    int get(){
        return x;
}
};
int main() {
    Encapsulation obj;
    obj.set(5);
    cout<<obj.get(); 
    return 0;
}
OUTPUT: 5


The variable x and the functions get() and set() are binded together which is nothing but encapsulation.

CAR = [Steering, Wheels, Engine, etc]

More Examples:
In real time we are using Encapsulation for Security Purpose.
Most commonly used example is the Medical Capsule.
Encapsulation = Abstraction + Data Hiding.

ABSTRACTION
Examples:
Dialling a number call: Some method internally runs and connects the call but what is it doing we don’t know.
Clicking on green button: Sends signals to calling person’s mobile but we are unaware of how it is doing.
ATM machines: Withdraw cash, deposit cash, check balance, print bills, etc. It shows only the main things like getting inputs and giving the output.
Gmail: Type email and password and click submit, It will show Compose, Inbox, Outbox, Sent mails. How it works internally?
TV Remote is a interface between User and TV. User does not need to know the inside circuit details.

INHERITANCE
There are mainly 5 types of inheritance,
1. Single level inheritance
2. Multi-level inheritance
3. Hierarchical inheritance
4. Hybrid inheritance
5. Multiple inheritance

Examples:
Parent Class: Animals.
Class: Insect
SubClass: Ants, Grasshopper

Insects all have almost the same characteristics, such as six legs and an exoskeleton.

Here also we can also inherit common properties like name, sound, color, breed from Animal class and create classes like Dog, Cat, Horse and etc.

You probably won’t finish this article. In fact, I may have already lost you to another tab in your browser. :(


POLYMORPHISM
Examples:
Base Class: Animal
Derived Class: “Cat” and “Dog”

class Animal{
public:
    nameNoise(){...}
}
class Cat: public Animal{
...
    meow(){...}
}
class Dog: public Animal{
    bark(){...}
...
}


We can override the “makeNoise” function that is inherited by the subclasses “Cat” and “Dog” to be “meow” and “bark,” respectively if the Animal class contains a way to create a noise named “makeNoise.”

Then, another function may be built that takes any Animal object as a parameter and calls the “makeNoise” member function on it.

Depending on the type of animal object that was supplied to the function, the noise will be either a “meow” or a “bark.”


Let’s say Samsung mobile has a 64 MP camera available i.e. — it is having a functionality of CameraClick().

Now same mobile is having Panorama mode available in camera, so functionality would be same but with mode.

This type is said to be Static polymorphism or Compile time polymorphism.

More examples:
Girl: This girl can be anything, a student, a writer, a friend, a mother, a sister, a daughter, a God.
This girl can exist in different ways in different situations.
Sound of animals: Different animals make different sounds.
Behaviour: We behave differently in front of elders, and friends. A single person is behaving differently at different time.
A Software Engineer can perform different task at different instance of time depending on the task assigned to him. She can do coding, testing, analysis and designing depending on the task assign and the requirement.
Stadium of commonwealth games. Single stadium but it perform multiple task like swimming, lawn tennis etc.
Summary:
OOPs have following features:
Object: Instance of Class
Class: Blue print of Object
Encapsulation: Protecting our Data | Secure implementation
Polymorphism: Different instances according to different behaviors depending on data types used
Abstraction: Hiding our irrelevant Data, or Restricts the data for relevance
Inheritance: One property of object is acquiring to another property of object, saves time.
Related Example 1:
Let’s consider a class Person,

It defines what a “Person” is.
— (She/he) is a human being,
— (She/he) got a brain, hands, legs, etc

The people are like an object.
— They obey the rules specified above (being a human being, having hands, legs etc) ~ Object, instances of the class.

Derived class: Artists
— Artists have all the properties of persons, they also have additional features like, they can draw nice pictures.~ Inheritance.

— An artist will have some understanding of pictures, colour combinations etc… like data inside an object. If you ask him to draw a nice picture(call the function to draw a picture), he draws(returns) a nice picture.

— The internal details like what was happening in his brain, movements of his fingers etc, are hidden from you (user). ~ Abstraction.

— His understandings (data), fingers, ears (functions) etc, some how coordinate internally to provide a simple interface (ears: you can tell him) to you(user). ~ Encapsulation.

Related Example 2:
Jeff Goodell: Would you explain, in simple terms, exactly what object-oriented software is?

Steve Jobs: Objects are like people. They’re living, breathing things that have knowledge inside them about how to do things and have memory inside them so they can remember things.

And rather than interacting with them at a very low level, you interact with them at a very high level of abstraction.

Here’s an example:
If I’m your laundry object, you can give me your dirty clothes and send me a message that says, “Can you get my clothes laundered, please?.”

I happen to know where the best laundry place in San Francisco is. And I speak English, and I have dollars in my pockets.

So I go out and hail a taxicab and tell the driver to take me to this place in San Francisco. I go get your clothes laundered, I jump back in the cab, I get back here. I give you your clean clothes and say, “Here are your clean clothes.”

You have no idea how I did that. You have no knowledge of the laundry place. Maybe you speak French, and you can’t even hail a taxi. You can’t pay for one, you don’t have dollars in your pocket.

Yet I knew how to do all of that. And you didn’t have to know any of it. All that complexity was hidden inside of me, and we were able to interact at a very high level of abstraction.

That’s what objects are. They encapsulate complexity, and the interfaces to that complexity are high level.

Related Example 3:
You bought an iPhone. Kudos!

Your mom and dad have iPhones too. It’s an iFamily! Each of those iPhone is a copy (Object) of the design specs (Class) stored with Apple.

You wan’t to open it up? Nope! Glued shut. Typical Jobs, Use the touchscreen and buttons to use.
~ Abstraction.

You wanna make a call? Play a movie? Hear some music? Camera. Touch screen. Accelerator. Gyrometer. Everything built into that slim device.
~ Encapsulation.

You hate the boring theme. Want to change it? Jailbreak! Cydia! You started with an iPhone, and ended with something way better.
~ Inheritance.

Your iPhone was brand new. Not anymore. Why? Because you broke the warranty by jailbreaking!
~ Polymorphism.


OOP Principles
There are some OOPS principle that need to be satisfied while creating a class. This principle is called as SOLID, where each letter has some specification.

SRP (The Single Responsibility Principle) — A class should have one, and only one responsibility.
OCP (The Open Closed Principle) — You should be able to extend a classes behaviour, without modifying it. (Inheritance)
LSP (The Liskov Substitution Principle) — Derived classes must be substitutable for their base classes. (Polymorphism)
ISP (The Interface Segregation Principle) — Make fine chopped interface instead of huge interface as client cannot be forced to implement an interface which they don’t use.
DIP (The Dependency Inversion Principle) — Depend on abstractions, not on concretions. (Abstraction)

Object-Oriented Programming or Java OOPs concept refers to languages that use objects in programming, they use objects as a primary source to implement what is to happen in the code. Objects are seen by the viewer or user, performing tasks you assign.

Object-oriented programming aims to implement real-world entities like inheritance, hiding, polymorphism, etc. in programming. The main aim of OOPs is to bind together the data and the functions that operate on them so that no other part of the code can access this data except that function. 

Let us discuss prerequisites by polishing concepts of method declaration and message passing. Starting off with the method declaration, it consists of six components: 

Access Modifier: Defines the access type of the method i.e. from where it can be accessed in your application. In Java, there are 4 types of access specifiers: 
public: Accessible in all classes in your application.
protected: Accessible within the package in which it is defined and in its subclass(es) (including subclasses declared outside the package).
private: Accessible only within the class in which it is defined.
default (declared/defined without using any modifier): Accessible within the same class and package within which its class is defined.
The return type: The data type of the value returned by the method or void if it does not return a value.
Method Name: The rules for field names apply to method names as well, but the convention is a little different.
Parameter list: Comma-separated list of the input parameters that are defined, preceded by their data type, within the enclosed parentheses. If there are no parameters, you must use empty parentheses ().
Exception list: The exceptions you expect the method to throw. You can specify these exception(s).
Method body: It is the block of code, enclosed between braces, that you need to execute to perform your intended operations.
Message Passing: Objects communicate with one another by sending and receiving information to each other. A message for an object is a request for execution of a procedure and therefore will invoke a function in the receiving object that generates the desired results. Message passing involves specifying the name of the object, the name of the function and the information to be sent.

Master OOP in Java Write cleaner, more modular, and reusable Java code by building a foundation in object-oriented programming with Educative’s interactive course Learn Object-Oriented Programming in Java. Sign up at Educative.io with the code GEEKS10 to save 10% on your subscription.
Now that we have covered the basic prerequisites, we will move on to the 4 pillars of OOPs which are as follows. But, let us start by learning about the different characteristics of an Object-Oriented Programming Language.

OOPS concepts are as follows: 

Class
Object 
Method and method passing
Pillars of OOPs
Abstraction
Encapsulation
Inheritance
Polymorphism
Compile-time polymorphism
Runtime polymorphism

A class is a user-defined blueprint or prototype from which objects are created. It represents the set of properties or methods that are common to all objects of one type. Using classes, you can create multiple objects with the same behavior instead of writing their code multiple times. This includes classes for objects occurring more than once in your code. In general, class declarations can include these components in order: 

Modifiers: A class can be public or have default access (Refer to this for details).
Class name: The class name should begin with the initial letter capitalized by convention.
Superclass (if any): The name of the class’s parent (superclass), if any, preceded by the keyword extends. A class can only extend (subclass) one parent.
Interfaces (if any): A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword implements. A class can implement more than one interface.
Body: The class body is surrounded by braces, { }.
An object is a basic unit of Object-Oriented Programming that represents real-life entities. A typical Java program creates many objects, which as you know, interact by invoking methods. The objects are what perform your code, they are the part of your code visible to the viewer/user. An object mainly consists of: 

State: It is represented by the attributes of an object. It also reflects the properties of an object.
Behavior: It is represented by the methods of an object. It also reflects the response of an object to other objects.
Identity: It is a unique name given to an object that enables it to interact with other objects.
Method: A method is a collection of statements that perform some specific task and return the result to the caller. A method can perform some specific task without returning anything. Methods allow us to reuse the code without retyping it, which is why they are considered time savers. In Java, every method must be part of some class, which is different from languages like C, C++, and Python. 


public class GFG {
    
    static String Employee_name;
    static float Employee_salary;

    static void set(String n, float p) {
        Employee_name  = n;
        Employee_salary  = p;
    }

    static void get() {
        System.out.println("Employee name is: " +Employee_name );
        System.out.println("Employee CTC is: " + Employee_salary);
    }

    public static void main(String args[]) {
        GFG.set("Rathod Avinash", 10000.0f);
        GFG.get();
    }
}

Output
Employee name is: Rathod Avinash
Employee CTC is: 10000.0
Let us now discuss the 4 pillars of OOPs:

Pillar 1: Abstraction
Data Abstraction is the property by virtue of which only the essential details are displayed to the user. The trivial or non-essential units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.
Data Abstraction may also be defined as the process of identifying only the required characteristics of an object, ignoring the irrelevant details. The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the object.

Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the car speed or applying brakes will stop the car, but he does not know how on pressing the accelerator, the speed is actually increasing. He does not know about the inner mechanism of the car or the implementation of the accelerators, brakes etc. in the car. This is what abstraction is. 

In Java, abstraction is achieved by interfaces and abstract classes. We can achieve 100% abstraction using interfaces.

The abstract method contains only method declaration but not implementation.

Demonstration of Abstract class 


//abstract class
abstract class GFG{
  //abstract methods declaration
  abstract void add();
  abstract void mul();
  abstract void div();
}
Pillar 2: Encapsulation
It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together the code and the data it manipulates. Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield. 

Technically, in encapsulation, the variables or the data in a class is hidden from any other class and can be accessed only through any member function of the class in which they are declared.
In encapsulation, the data in a class is hidden from other classes, which is similar to what data-hiding does. So, the terms “encapsulation” and “data-hiding” are used interchangeably.
Encapsulation can be achieved by declaring all the variables in a class as private and writing public methods in the class to set and get the values of the variables.
Demonstration of Encapsulation:


//Encapsulation using private modifier 

//Employee class contains private data called employee id and employee name
class Employee {
    private int empid;
      private String ename;
}
Pillar 3: Inheritance 
Inheritance is an important pillar of OOP (Object Oriented Programming). It is the mechanism in Java by which one class is allowed to inherit the features (fields and methods) of another class. We are achieving inheritance by using extends keyword. Inheritance is also known as “is-a” relationship.

Let us discuss some frequently used important terminologies:

Superclass: The class whose features are inherited is known as superclass (also known as base or parent class).
Subclass: The class that inherits the other class is known as subclass (also known as derived or extended or child class). The subclass can add its own fields and methods in addition to the superclass fields and methods.
Reusability: Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.
Demonstration of Inheritance :


//base class or parent class or super class
class A{
  //parent class methods
  void method1(){}
  void method2(){}
}

//derived class or child class or base class
class B extends A{  //Inherits parent class methods
  //child class methods
  void method3(){}
  void method4(){}
}
Pillar 4: Polymorphism
It refers to the ability of object-oriented programming languages to differentiate between entities with the same name efficiently. This is done by Java with the help of the signature and declaration of these entities. The ability to appear in many forms is called polymorphism.

E.g.


sleep(1000) //millis

sleep(1000,2000) //millis,nanos
 
Note: Polymorphism in Java is mainly of 2 types: 

Overloading
Overriding 
Example


// Java program to Demonstrate Polymorphism

// This class will contain
// 3 methods with same name,
// yet the program will
// compile & run successfully
public class Sum {

    // Overloaded sum().
    // This sum takes two int parameters
    public int sum(int x, int y)
    {
        return (x + y);
    }

    // Overloaded sum().
    // This sum takes three int parameters
    public int sum(int x, int y, int z)
    {
        return (x + y + z);
    }

    // Overloaded sum().
    // This sum takes two double parameters
    public double sum(double x, double y)
    {
        return (x + y);
    }

    // Driver code
    public static void main(String args[])
    {
        Sum s = new Sum();
        System.out.println(s.sum(10, 20));
        System.out.println(s.sum(10, 20, 30));
        System.out.println(s.sum(10.5, 20.5));
    }
}

Output
30
60
31.0
Conclusion
The Object Oriented Programming (OOPs) concept in Java is a powerful way to organize and write code. It uses key ideas like classes, objects, inheritance, polymorphism, encapsulation, and abstraction to create flexible and reusable code. By using the Java OOPs concept, programmers can build complex applications more efficiently, making the code easier to manage, understand, and modify. Overall, Java’s OOPs concepts help in creating robust and scalable software solutions. To explore more Java concepts you can enroll free Java course offered by GeeksforGeeks.

Object Oriented Programming (OOPs) Concept in Java – FAQ
What is OOPs concept in Java?
OOPs (Object-Oriented Programming) is a programming paradigm based on the concept of objects, which can contain data in the form of fields (attributes or properties) and code in the form of procedures (methods or functions). In Java, OOPs concepts include encapsulation, inheritance, polymorphism, and abstraction.

Why is OOPs important in Java?
OOPs helps in organizing and structuring code in a more manageable way, making it easier to maintain and scale Java applications. It also promotes code reusability, modularity, and flexibility, leading to efficient and robust software development.

What are the main principles of OOPs in Java?
The main principles of OOPs in Java are encapsulation, inheritance, polymorphism, and abstraction. Encapsulation ensures that the internal state of an object is hidden and can only be accessed through public methods. Inheritance allows one class to inherit properties and behavior from another. Polymorphism enables objects to be treated as instances of their parent class. Abstraction focuses on hiding the implementation details and showing only the necessary information to the outside world.

How is OOPs implemented in Java?
In Java, OOPs is implemented through classes and objects. A class serves as a blueprint for creating objects, which are instances of that class. Each object has its own set of attributes (variables) and methods (functions). By following OOPs concepts like encapsulation, inheritance, polymorphism, and abstraction, Java developers can design well-structured and maintainable code.

What are the advantages of using OOPs in Java?
Some advantages of using OOPs in Java include code reusability, modularity, flexibility, scalability, and easier maintenance. OOPs enables developers to model real-world entities as objects, leading to more intuitive and organized code. It also supports features like inheritance and polymorphism, which enhance the extensibility and readability of Java applications.

Can you provide an example of OOPs concept implementation in Java?
Sure! An example of OOPs concept implementation in Java is creating a ‘Car’ class with attributes like ‘make’, ‘model’, and ‘year’, along with methods like ‘start()’, ‘accelerate()’, and ‘stop()’. By instantiating objects from the ‘Car’ class and calling its methods, we can simulate the behavior of different car instances in a structured and object-oriented manner.


 Object-Oriented Programming concepts are very important. Without an idea of OOP concepts, you will not be able to design systems in an object-oriented programming model. It simplifies software development and maintenance.

Core OOPs Concepts:
Object
Class
Abstraction
Encapsulation
Inheritance
Polymorphism
Let's discuss each OOP concept with a real-world example.

1. Object
An Object is a real-time entity having some state and behavior. In Java, an Object is an instance of the class having instance variables (state) and methods (behavior). The object of a class can be created by using the new keyword in the Java Programming language.

A class is a template or blueprint from which objects are created. So, an object is the instance (result) of a class.

Various Definitions of an Object:

An object is a real-world entity.
An object is a runtime entity.
An object is an entity that has a state and behavior.
An object is an instance of a class.
Real-world examples:

Dogs have states (name, color, breed, hungry) and behaviors (barking, fetching, wagging tail). Other examples include Chairs, Bikes, Markers, Pens, Tables, Cars, Books, Apples, Bags, etc. These can be physical or logical (tangible and intangible). Object Example
Bicycles also have states (current gear, current pedal cadence, current speed) and behaviors (changing gear, changing pedal cadence, applying brakes). 
Read more about Objects in Java with examples at What Is Object in Java with Programming Examples.

2. Class
A class is a group of objects that have common properties. It is a template or blueprint from which objects are created. In short, a class is the specification or template of an object.

Read more about Class in Java with examples at What is Class in Java with Programming Examples.

Real-world example: Circle Let’s look at an example of a class and analyze its various parts in the below diagram. This example declares the class Circle, which has the member variables x, y, and radius of type Integer and the two member methods, area() and fillColor().

The below diagram shows a Circle class, which is a template for creating three objects: Class is a template for creating objects

3. Abstraction
Abstraction means hiding lower-level details and exposing only the essential and relevant details to the users.

Real-world examples:

Car: A car abstracts the internal details and exposes to the driver only those details that are relevant to the driver's interaction with the car. Car Abstraction Example
ATM Machine: An ATM machine allows users to perform operations like cash withdrawal, money transfer, and retrieving mini-statements without knowing the internal details of the ATM. ATM Abstraction Example
Read more about Abstraction in Java with examples at Abstraction in Java with Example.

4. Encapsulation
Encapsulation is the process of wrapping data and methods in a single unit.

In OOP, data and methods operating on that data are combined together to form a single unit, which is referred to as a Class. Encapsulation is the mechanism that binds together code and the data it manipulates and keeps both safe from outside interference and misuse.

Real-world examples:

Capsule: A capsule wraps different medicines inside it. Encapsulation Example
Read more at Encapsulation in Java with Example.

5. Inheritance
Inheritance is a process of obtaining the data members and methods from one class to another class. It is a fundamental feature of object-oriented programming.

Inheritance - IS-A relationship between a superclass and its subclasses.

Super Class: The class whose features are inherited is known as a superclass (or a base class or a parent class).
Sub Class: The class that inherits the other class is known as a subclass (or a derived class, extended class, or child class
). The subclass can add its own fields and methods in addition to the superclass fields and methods.

Real-world examples:

Child and Parent: All the properties of a father are inherited by his son. Inheritance Example
Java Library: The extensive use of inheritance in the Java library. For example, the Number class abstracts various numerical (reference) types such as Byte, Integer, Float, Double, Short, and BigDecimal. Inheritance in Java Core
Read more about Inheritance at Inheritance in Java with Example.

6. Polymorphism
Polymorphism is the process of representing one form in multiple forms.

Definitions of Polymorphism:

Polymorphism allows us to perform a single action in different ways.
Polymorphism allows you to define one interface and have multiple implementations.
We can create functions or reference variables that behave differently in different programmatic contexts.
Polymorphism means many forms.
Real-world example: Suppose if you are in a classroom at that time you behave like a student, when you are in the market at that time you behave like a customer, and when you are at home at that time you behave like a son or daughter. Here one person presents different behaviors in different contexts. Polymorphism Real-World Example

Read more at Polymorphism in Java with Example.

Apart from these core OOPs concepts, there are some other terms that are used in Object-Oriented design:

Association
Composition
Aggregation
Delegation
Coupling
Cohesion
Association
Definition: Association represents a relationship between two or more objects where all objects have their own lifecycle and there is no owner.

Real-world example:

Teacher and Student: A teacher can teach multiple students, and a student can be taught by multiple teachers. Both the teacher and student objects have their own lifecycle and can exist independently.
class Teacher {
    private String name;
    // constructor, getters, setters
}

class Student {
    private String name;
    // constructor, getters, setters
}

public class AssociationExample {
    public static void main(String[] args) {
        Teacher teacher = new Teacher("Mr. Smith");
        Student student = new Student("John Doe");
        // Association between teacher and student
    }
}
Read more on Association in Java with Example.

Composition
Definition: Composition is a strong form of association where one class (the whole) contains another class (the part) and the part cannot exist without the whole.

Real-world example:

Car and Engine: A car has an engine, and the engine cannot exist independently without the car.
class Engine {
    private String type;

    public Engine(String type) {
        this.type = type;
    }
    // getters, setters
}

class Car {
    private String model;
    private Engine engine;

    public Car(String model, Engine engine) {
        this.model = model;
        this.engine = engine;
    }
    // getters, setters
}

public class CompositionExample {
    public static void main(String[] args) {
        Engine engine = new Engine("V8");
        Car car = new Car("Mustang", engine);
        // Composition relationship
    }
}
Read more on Composition in Java with Example.

Aggregation
Definition: Aggregation is a weak form of association where one class (the whole) contains another class (the part) but the part can exist independently of the whole.

Real-world example:

Library and Books: A library contains books, but a book can exist independently of the library.
class Book {
    private String title;

    public Book(String title) {
        this.title = title;
    }
    // getters, setters
}

class Library {
    private String name;
    private List<Book> books;

    public Library(String name, List<Book> books) {
        this.name = name;
        this.books = books;
    }
    // getters, setters
}

public class AggregationExample {
    public static void main(String[] args) {
        Book book1 = new Book("1984");
        Book book2 = new Book("To Kill a Mockingbird");
        List<Book> books = Arrays.asList(book1, book2);
        Library library = new Library("Central Library", books);
        // Aggregation relationship
    }
}
Read more on Aggregation in Java with Example.

Delegation
Definition: Delegation is a design pattern where an object expresses certain behavior to the outside but delegates responsibility for implementing that behavior to an associated object.

Real-world example:

Ticket Booking: A travel agent delegates the responsibility of booking different types of tickets to specialized booking classes.
interface Booking {
    void bookTicket();
}

class TrainBooking implements Booking {
    @Override
    public void bookTicket() {
        System.out.println("Train ticket booked");
    }
}

class FlightBooking implements Booking {
    @Override
    public void bookTicket() {
        System.out.println("Flight ticket booked");
    }
}

class BookingAgent {
    private Booking booking;

    public BookingAgent(Booking booking) {
        this.booking = booking;
    }

    public void book() {
        booking.bookTicket();
    }
}

public class DelegationExample {
    public static void main(String[] args) {
        BookingAgent agent = new BookingAgent(new TrainBooking());
        agent.book(); // Delegates booking to TrainBooking

        agent = new BookingAgent(new FlightBooking());
        agent.book(); // Delegates booking to FlightBooking
    }
}
Read more on Delegation in Java with Example.

Coupling
Definition: Coupling refers to the degree to which one class knows about another class. Lower coupling is preferred to reduce dependencies between classes.

Real-world example:

Electric Appliance and Plug: An electric appliance can be plugged into any socket without knowing the specifics of the electrical system.
class Plug {
    public void plugIn() {
        System.out.println("Plugged in");
    }
}

class Appliance {
    private Plug plug;

    public Appliance(Plug plug) {
        this.plug = plug;
    }

    public void use() {
        plug.plugIn();
    }
}

public class CouplingExample {
    public static void main(String[] args) {
        Plug plug = new Plug();
        Appliance appliance = new Appliance(plug);
        appliance.use();
    }
}
Read more on Coupling in Java with Example.

Cohesion
Definition: Cohesion refers to the degree to which the elements of a module/class belong together. High cohesion is preferred as it indicates that a class has a well-defined responsibility.

Real-world example:

ATM Machine: An ATM class should only handle operations related to ATM functions like withdrawing money, checking balance, etc.
class ATM {
    public void withdrawMoney() {
        // Code to withdraw money
    }

    public void checkBalance() {
        // Code to check balance
    }
}

public class CohesionExample {
    public static void main(String[] args) {
        ATM atm = new ATM();
        atm.withdrawMoney();
        atm.checkBalance();
    }
}
Read more on Cohesion in Java with Example.

Conclusion
We have discussed the following OOPs concepts with real-world examples:

Object
Class
Abstraction
Encapsulation
Inheritance
Polymorphism
Association
Composition
Aggregation
Delegation
Coupling
Cohesion


Static Keyword
The static keyword in Java acts as an access modifier. When a particular class, method, or variable is declared using the static keyword, then those declared items. are prevented from modifications or gaining access. Their original values and properties are left unchanged.

This Keyword
The term "this" is a keyword in Java, which is a reference variable that refers to the current object. It is used in various places based on its requirements. A few of the implementations include:

To invoke a method from the current class
To invoke a constructor from the current class
To refer an instance variable from the current class
To return the instance of the current class from a method
To pass the arguments to a method or constructor 

What Is an Object?
An object is the building block for every object-oriented programming language. An object is created when a specific class is used. An object may include properties and methods. Sometimes it may also include another object.

What Is a Constructor?
A constructor is a unique method that makes use of the class as a blueprint. It initializes the class objects and constructs them.

A Java method is a location where users define the operations that they’d like to apply to their data members. A programmer defines the method inside the class.

OOPs Concepts in Java
Object-oriented programming is a structured approach to building software. Through it, classes are the building blueprints holding the methods, and objects are the basic building blocks that store the class's instances. 

In Java, four governing laws define Object-Oriented Programming. They include:

Abstraction 
Encapsulation
Inheritance
Polymorphism

How to Implement the Revolutionary OOPs Concepts in Java
Lesson 10 of 43By Ravikiran A S

Last updated on Jul 16, 202436225
How to Implement the Revolutionary OOPs Concepts in Java
PreviousNext
Table of Contents
What Is a Class?Static KeywordThis KeywordWhat Is an Object?What Is a Constructor?View More
There’s a reason why Java is one of the top two programming languages in the world—it has some of the most powerful and useful features available. Like OOPs concepts in Java.

OOPs concepts in Java mainly focus on providing an organized and clear structure to data members; and manipulation methods in a program in the form of an object. Unlike procedural programming, the revolutionary object-oriented programming approach improvises the programming capabilities and functionalities to an exponential level.

What Is a Class?
As we mentioned before, a class in object-oriented programming is a blueprint for storing data members and data manipulating methods combined in the form of a data structure. 

To declare a class, we use the keyword class, followed by a user-defined name.

Syntax:

<Access Modifier> class <name_of_the_class>{

 Data members;

 Data methods;

 Class Statements;

}

Example:

package Simplilearn;

import java.util.Scanner;

public class Area {

   public static void main (String[] args)

   {

    Scanner scanner = new Scanner(System.in);

    System.out.println("Enter the length of the Rectangle:");

    double l = scanner.nextDouble();

    System.out.println("Enter the breadth of the Rectangle:");

    double b = scanner.nextDouble();

    double a = l*b;

    System.out.println("Area of the given Rectangle is:"+a);

   }

}

//Output:

Enter the length of the Rectangle:

21

Enter the breadth of the Rectangle:

34

Area of the given Rectangle is:714.0

Static Keyword
The static keyword in Java acts as an access modifier. When a particular class, method, or variable is declared using the static keyword, then those declared items. are prevented from modifications or gaining access. Their original values and properties are left unchanged.

Syntax:

<access_modifier> static <name_of_the_class>;

static <data type> <name_of_the_variable>;

static <method_name>;

Example:

package Simplilearn;

class Employee {

 int E_ID;

 String name;

 static String Organisation = "XYZ-Org";

 Employee(int e_id, String N) {

  E_ID = e_id;

  name = N;

 }

 void display() {

  System.out.println(E_ID + " " + name + " " + Organisation);

 }

}

public class Static {

 public static void main(String args[]) {

  Employee e1 = new Employee(10432, "John");

  Employee e2 = new Employee(10483, "Anthony");

  Employee e3 = new Employee(10232, "Steve");

  Employee e4 = new Employee(10856, "Thomas");

  e1.display();

  e2.display();

  e3.display();

  e4.display();

 }

}

//Output:

10432 John XYZ-Org

10483 Anthony XYZ-Org

10232 Steve XYZ-Org

10856 Thomas XYZ-Org

This Keyword
The term "this" is a keyword in Java, which is a reference variable that refers to the current object. It is used in various places based on its requirements. A few of the implementations include:

To invoke a method from the current class
To invoke a constructor from the current class
To refer an instance variable from the current class
To return the instance of the current class from a method
To pass the arguments to a method or constructor 
Syntax:

this.<method_name>;

this.<variable_name>;

Example:

package Simplilearn;

class StudentData {

 int ID;

 String name;

 int rank;

 StudentData(int ID, String name, int rank) {

  this.ID = ID;

  this.name = name;

  this.rank = rank;

 }

 void display() {

  System.out.println(ID + " " + name + " " + rank);

 }

}

public class This {

 public static void main(String args[]) {

  StudentData student1 = new StudentData(8010, "sam", 18);

  StudentData student2 = new StudentData(8121, "Jennifer ", 3);

  student1.display();

  student2.display();

 }

}

//Output:

8010 sam 18

8121 Jennifer 3

What Is an Object?
An object is the building block for every object-oriented programming language. An object is created when a specific class is used. An object may include properties and methods. Sometimes it may also include another object.

Syntax:

<class_name> <object_name> = new <class_name>(“<parameters”);

Example:

Employee e1 = new Employee ("Sharon", 102030, "B+");

What Is a Constructor?
A constructor is a unique method that makes use of the class as a blueprint. It initializes the class objects and constructs them.

Syntax: 

<class_name> <object_name> = new <class_name>(“<parameters”);

Example:

Student s1 = new Student (“Jayson”, 22901, “First-Grade”);

What Is a Method?
A Java method is a location where users define the operations that they’d like to apply to their data members. A programmer defines the method inside the class.

Syntax:

<Access_Modifier> <Datatype> <Method_Name> (<Parameters>) {

 Return <Result>;

}

Example:

Public float sum(float x, float y) {

 return z=x+y;

}

OOPs Concepts in Java
Object-oriented programming is a structured approach to building software. Through it, classes are the building blueprints holding the methods, and objects are the basic building blocks that store the class's instances. 

In Java, four governing laws define Object-Oriented Programming. They include:

Abstraction 
Encapsulation
Inheritance
Polymorphism
Abstraction in Java OOPs Concepts
abstraction.


In object-oriented programming, abstraction keeps the user from viewing the implementation of the sophisticated methods. In other words, users can only see the necessary details and information that they wish to see and hide the implementation's unnecessary complexities.

In Java, the abstraction is achieved when the following special classes are incorporated:

Interface Class
Abstract Class

An interface in Java acts as a container that stores only the method's signatures and exclude the data members and their method definitions. Using interfaces reduces the code complexity and improves the code’s readability.

An abstract class is almost identical to an interface, but the difference is, an abstract class can incorporate data members and their method definitions.

Encapsulation is a procedure of binding the data members and data methods together inside the user-defined class, which should be declared private.

Inheritance in Java OOPs Concepts 
Inheritance is one of the object-oriented programming approaches that simplify software development. It enables the ability to build new classes by inheriting data members and methods, as well as the properties of previously defined classes.

The inheriting class is called a child/derived class, and the inherited class is called the parent/base class. The process of inheriting the parent/base class is carried out in different ways. We will now discuss each one of them in detail. 

How to Implement the Revolutionary OOPs Concepts in Java
Lesson 10 of 43By Ravikiran A S

Last updated on Jul 16, 202436225
How to Implement the Revolutionary OOPs Concepts in Java
PreviousNext
Table of Contents
What Is a Class?Static KeywordThis KeywordWhat Is an Object?What Is a Constructor?View More
There’s a reason why Java is one of the top two programming languages in the world—it has some of the most powerful and useful features available. Like OOPs concepts in Java.

OOPs concepts in Java mainly focus on providing an organized and clear structure to data members; and manipulation methods in a program in the form of an object. Unlike procedural programming, the revolutionary object-oriented programming approach improvises the programming capabilities and functionalities to an exponential level.

What Is a Class?
As we mentioned before, a class in object-oriented programming is a blueprint for storing data members and data manipulating methods combined in the form of a data structure. 

To declare a class, we use the keyword class, followed by a user-defined name.

Syntax:

<Access Modifier> class <name_of_the_class>{

 Data members;

 Data methods;

 Class Statements;

}

Example:

package Simplilearn;

import java.util.Scanner;

public class Area {

   public static void main (String[] args)

   {

    Scanner scanner = new Scanner(System.in);

    System.out.println("Enter the length of the Rectangle:");

    double l = scanner.nextDouble();

    System.out.println("Enter the breadth of the Rectangle:");

    double b = scanner.nextDouble();

    double a = l*b;

    System.out.println("Area of the given Rectangle is:"+a);

   }

}

//Output:

Enter the length of the Rectangle:

21

Enter the breadth of the Rectangle:

34

Area of the given Rectangle is:714.0

Static Keyword
The static keyword in Java acts as an access modifier. When a particular class, method, or variable is declared using the static keyword, then those declared items. are prevented from modifications or gaining access. Their original values and properties are left unchanged.

Syntax:

<access_modifier> static <name_of_the_class>;

static <data type> <name_of_the_variable>;

static <method_name>;

Example:

package Simplilearn;

class Employee {

 int E_ID;

 String name;

 static String Organisation = "XYZ-Org";

 Employee(int e_id, String N) {

  E_ID = e_id;

  name = N;

 }

 void display() {

  System.out.println(E_ID + " " + name + " " + Organisation);

 }

}

public class Static {

 public static void main(String args[]) {

  Employee e1 = new Employee(10432, "John");

  Employee e2 = new Employee(10483, "Anthony");

  Employee e3 = new Employee(10232, "Steve");

  Employee e4 = new Employee(10856, "Thomas");

  e1.display();

  e2.display();

  e3.display();

  e4.display();

 }

}

//Output:

10432 John XYZ-Org

10483 Anthony XYZ-Org

10232 Steve XYZ-Org

10856 Thomas XYZ-Org

This Keyword
The term "this" is a keyword in Java, which is a reference variable that refers to the current object. It is used in various places based on its requirements. A few of the implementations include:

To invoke a method from the current class
To invoke a constructor from the current class
To refer an instance variable from the current class
To return the instance of the current class from a method
To pass the arguments to a method or constructor 
Syntax:

this.<method_name>;

this.<variable_name>;

Example:

package Simplilearn;

class StudentData {

 int ID;

 String name;

 int rank;

 StudentData(int ID, String name, int rank) {

  this.ID = ID;

  this.name = name;

  this.rank = rank;

 }

 void display() {

  System.out.println(ID + " " + name + " " + rank);

 }

}

public class This {

 public static void main(String args[]) {

  StudentData student1 = new StudentData(8010, "sam", 18);

  StudentData student2 = new StudentData(8121, "Jennifer ", 3);

  student1.display();

  student2.display();

 }

}

//Output:

8010 sam 18

8121 Jennifer 3

What Is an Object?
An object is the building block for every object-oriented programming language. An object is created when a specific class is used. An object may include properties and methods. Sometimes it may also include another object.

Syntax:

<class_name> <object_name> = new <class_name>(“<parameters”);

Example:

Employee e1 = new Employee ("Sharon", 102030, "B+");

What Is a Constructor?
A constructor is a unique method that makes use of the class as a blueprint. It initializes the class objects and constructs them.

Syntax: 

<class_name> <object_name> = new <class_name>(“<parameters”);

Example:

Student s1 = new Student (“Jayson”, 22901, “First-Grade”);

What Is a Method?
A Java method is a location where users define the operations that they’d like to apply to their data members. A programmer defines the method inside the class.

Syntax:

<Access_Modifier> <Datatype> <Method_Name> (<Parameters>) {

 Return <Result>;

}

Example:

Public float sum(float x, float y) {

 return z=x+y;

}

OOPs Concepts in Java
Object-oriented programming is a structured approach to building software. Through it, classes are the building blueprints holding the methods, and objects are the basic building blocks that store the class's instances. 

In Java, four governing laws define Object-Oriented Programming. They include:

Abstraction 
Encapsulation
Inheritance
Polymorphism
Abstraction in Java OOPs Concepts
abstraction.


In object-oriented programming, abstraction keeps the user from viewing the implementation of the sophisticated methods. In other words, users can only see the necessary details and information that they wish to see and hide the implementation's unnecessary complexities.

In Java, the abstraction is achieved when the following special classes are incorporated:

Interface Class
Abstract Class
Interface in Java
/interface

An interface in Java acts as a container that stores only the method's signatures and exclude the data members and their method definitions. Using interfaces reduces the code complexity and improves the code’s readability.

Syntax:

<Acees_Modifier> interface <Interface_Name> {

 <Method_Signatures>;

}

Example:

package simplilearn;

public interface Area {

 public void Square();

 public void Circle();

 public void Rectangle();

 public void Triangle();

}

//Class




package simplilearn;

import java.util.Scanner;

public class shapeArea implements Area {

 public void Circle() {

  Scanner kb = new Scanner(System.in);

  System.out.println("Enter the radius of the circle");

  double r = kb.nextInt();

  double areaOfCircle = 3.142 * r * r;

  System.out.println("Area of the circle is" + areaOfCircle);

 }

 @Override

 public void Square() {

  // TODO Auto-generated method stub

  Scanner kb2 = new Scanner(System.in);

  System.out.println("Input the length of the side of the square");

  double s = kb2.nextInt();

  double areaOfSquare = s * s;

  System.out.println("Area of the square is" + areaOfSquare);

 }

 @Override

 public void Rectangle() {

  // TODO Auto-generated method stub

  Scanner kb3 = new Scanner(System.in);

  System.out.println("Enter the length of the Rectangle");

  double l = kb3.nextInt();

  System.out.println("Enter the breadth of the Rectangle");

  double b = kb3.nextInt();

  double areaOfRectangle = l * b;

  System.out.println("Area of the Rectangle is" + areaOfRectangle);

 }

 @Override

 public void Triangle() {

  // TODO Auto-generated method stub

  Scanner kb4 = new Scanner(System.in);

  System.out.println("Enter the base of the Triangle");

  double base = kb4.nextInt();

  System.out.println("Enter the height of the Triangle");

  double h = kb4.nextInt();

  double areaOfTriangle = 0.5 * base * h;

  System.out.println("Area of the Triangle is" + areaOfTriangle);

 }

 public static void main(String[] args) {

  shapeArea geometry = new shapeArea();

  geometry.Circle();

  geometry.Square();

  geometry.Rectangle();

  geometry.Triangle();

 }

}

Abstract Classes in Java
abstract-classes

An abstract class is almost identical to an interface, but the difference is, an abstract class can incorporate data members and their method definitions.

Syntax:

<Access_Modifier> abstract class <Name_of_the_class> {

 <Data Members>;

 <Data Methods>;

}

Example:

package Simplilearn;

public abstract class Person {

 private String Name;

 private String Gender;

 public Person(String nm, String Gen) {

  this.Name = nm;

  this.Gender = Gen;

 }

 public abstract void work();

 @Override

 public String toString() {

  return "Name=" + this.Name + "::Gender=" + this.Gender;

 }

 public void changeName(String newName) {

  this.Name = newName;

 }

 public void Exam() {

  // TODO Auto-generated method stub

  

 }

}

Class

package abstraction;

public class Employee extends Person {

 private int EmpId;

 public Employee(String EmployeeName, String Gen, int EmployeeID) {

  super(EmployeeName, Gen);

  this.EmpId = EmployeeID;

 }

 @Override

 public void Office() {

  if (EmpId == 0) {

   System.out.println("Employee Logged Out");

  } else {

   System.out.println("Employee Logged In");

  }

 }

 public static void main(String args[]) {

  Person employee = new Employee("Pavithra", "Female", 1094826);

  employee.Office();

  employee.changeName("Pavithra Tripathy");

  System.out.println(employee.toString());

 }

}

Encapsulation in Java OOPs Concepts
encapsulation

Encapsulation is a procedure of binding the data members and data methods together inside the user-defined class, which should be declared private.

Syntax:

<Access_Modifier> class <Class_Name> {

 private <Data_Members>;

 private <Data_Methods>;

}

Example:

package Simplilearn;

public class emp {

 public static void main(String[] args) {

  encapsule emp = new encapsule();

  emp.setName("Robert");

  System.out.println(emp.Name());

 }

}

package Simplilearn;

public class encapsule {

 private String empName;

 public String Name() {

  return empName;

 }

 public void setName(String empName) {

  this.empName = empName;

 }

}

//Output:

Robert

Inheritance in Java OOPs Concepts 
Inheritance is one of the object-oriented programming approaches that simplify software development. It enables the ability to build new classes by inheriting data members and methods, as well as the properties of previously defined classes.

The inheriting class is called a child/derived class, and the inherited class is called the parent/base class. The process of inheriting the parent/base class is carried out in different ways. We will now discuss each one of them in detail. 

Types of Inheritance

Single inheritance consists of one parent class and one child class. Here, child classes inherit parent class methods and data members.

Multi-level inheritance is also a parent-child inheritance relation, but the difference is another child class inherits the child class.

Java will not support multiple inheritance, as it ends up with a severe ambiguity.
Interface resolves the diamond problem.

Hierarchical inheritance is a parent-child relationship. The only difference is that multiple child classes inherit a single parent class.

How to Implement the Revolutionary OOPs Concepts in Java
Lesson 10 of 43By Ravikiran A S

Last updated on Jul 16, 202436225
How to Implement the Revolutionary OOPs Concepts in Java
PreviousNext
Table of Contents
What Is a Class?Static KeywordThis KeywordWhat Is an Object?What Is a Constructor?View More
There’s a reason why Java is one of the top two programming languages in the world—it has some of the most powerful and useful features available. Like OOPs concepts in Java.

OOPs concepts in Java mainly focus on providing an organized and clear structure to data members; and manipulation methods in a program in the form of an object. Unlike procedural programming, the revolutionary object-oriented programming approach improvises the programming capabilities and functionalities to an exponential level.

What Is a Class?
As we mentioned before, a class in object-oriented programming is a blueprint for storing data members and data manipulating methods combined in the form of a data structure. 

To declare a class, we use the keyword class, followed by a user-defined name.

Syntax:

<Access Modifier> class <name_of_the_class>{

 Data members;

 Data methods;

 Class Statements;

}

Example:

package Simplilearn;

import java.util.Scanner;

public class Area {

   public static void main (String[] args)

   {

    Scanner scanner = new Scanner(System.in);

    System.out.println("Enter the length of the Rectangle:");

    double l = scanner.nextDouble();

    System.out.println("Enter the breadth of the Rectangle:");

    double b = scanner.nextDouble();

    double a = l*b;

    System.out.println("Area of the given Rectangle is:"+a);

   }

}

//Output:

Enter the length of the Rectangle:

21

Enter the breadth of the Rectangle:

34

Area of the given Rectangle is:714.0

Static Keyword
The static keyword in Java acts as an access modifier. When a particular class, method, or variable is declared using the static keyword, then those declared items. are prevented from modifications or gaining access. Their original values and properties are left unchanged.

Syntax:

<access_modifier> static <name_of_the_class>;

static <data type> <name_of_the_variable>;

static <method_name>;

Example:

package Simplilearn;

class Employee {

 int E_ID;

 String name;

 static String Organisation = "XYZ-Org";

 Employee(int e_id, String N) {

  E_ID = e_id;

  name = N;

 }

 void display() {

  System.out.println(E_ID + " " + name + " " + Organisation);

 }

}

public class Static {

 public static void main(String args[]) {

  Employee e1 = new Employee(10432, "John");

  Employee e2 = new Employee(10483, "Anthony");

  Employee e3 = new Employee(10232, "Steve");

  Employee e4 = new Employee(10856, "Thomas");

  e1.display();

  e2.display();

  e3.display();

  e4.display();

 }

}

//Output:

10432 John XYZ-Org

10483 Anthony XYZ-Org

10232 Steve XYZ-Org

10856 Thomas XYZ-Org

This Keyword
The term "this" is a keyword in Java, which is a reference variable that refers to the current object. It is used in various places based on its requirements. A few of the implementations include:

To invoke a method from the current class
To invoke a constructor from the current class
To refer an instance variable from the current class
To return the instance of the current class from a method
To pass the arguments to a method or constructor 
Syntax:

this.<method_name>;

this.<variable_name>;

Example:

package Simplilearn;

class StudentData {

 int ID;

 String name;

 int rank;

 StudentData(int ID, String name, int rank) {

  this.ID = ID;

  this.name = name;

  this.rank = rank;

 }

 void display() {

  System.out.println(ID + " " + name + " " + rank);

 }

}

public class This {

 public static void main(String args[]) {

  StudentData student1 = new StudentData(8010, "sam", 18);

  StudentData student2 = new StudentData(8121, "Jennifer ", 3);

  student1.display();

  student2.display();

 }

}

//Output:

8010 sam 18

8121 Jennifer 3

What Is an Object?
An object is the building block for every object-oriented programming language. An object is created when a specific class is used. An object may include properties and methods. Sometimes it may also include another object.

Syntax:

<class_name> <object_name> = new <class_name>(“<parameters”);

Example:

Employee e1 = new Employee ("Sharon", 102030, "B+");

What Is a Constructor?
A constructor is a unique method that makes use of the class as a blueprint. It initializes the class objects and constructs them.

Syntax: 

<class_name> <object_name> = new <class_name>(“<parameters”);

Example:

Student s1 = new Student (“Jayson”, 22901, “First-Grade”);

What Is a Method?
A Java method is a location where users define the operations that they’d like to apply to their data members. A programmer defines the method inside the class.

Syntax:

<Access_Modifier> <Datatype> <Method_Name> (<Parameters>) {

 Return <Result>;

}

Example:

Public float sum(float x, float y) {

 return z=x+y;

}

OOPs Concepts in Java
Object-oriented programming is a structured approach to building software. Through it, classes are the building blueprints holding the methods, and objects are the basic building blocks that store the class's instances. 

In Java, four governing laws define Object-Oriented Programming. They include:

Abstraction 
Encapsulation
Inheritance
Polymorphism
Abstraction in Java OOPs Concepts
abstraction.


In object-oriented programming, abstraction keeps the user from viewing the implementation of the sophisticated methods. In other words, users can only see the necessary details and information that they wish to see and hide the implementation's unnecessary complexities.

In Java, the abstraction is achieved when the following special classes are incorporated:

Interface Class
Abstract Class
Interface in Java
/interface

An interface in Java acts as a container that stores only the method's signatures and exclude the data members and their method definitions. Using interfaces reduces the code complexity and improves the code’s readability.

Syntax:

<Acees_Modifier> interface <Interface_Name> {

 <Method_Signatures>;

}

Example:

package simplilearn;

public interface Area {

 public void Square();

 public void Circle();

 public void Rectangle();

 public void Triangle();

}

//Class




package simplilearn;

import java.util.Scanner;

public class shapeArea implements Area {

 public void Circle() {

  Scanner kb = new Scanner(System.in);

  System.out.println("Enter the radius of the circle");

  double r = kb.nextInt();

  double areaOfCircle = 3.142 * r * r;

  System.out.println("Area of the circle is" + areaOfCircle);

 }

 @Override

 public void Square() {

  // TODO Auto-generated method stub

  Scanner kb2 = new Scanner(System.in);

  System.out.println("Input the length of the side of the square");

  double s = kb2.nextInt();

  double areaOfSquare = s * s;

  System.out.println("Area of the square is" + areaOfSquare);

 }

 @Override

 public void Rectangle() {

  // TODO Auto-generated method stub

  Scanner kb3 = new Scanner(System.in);

  System.out.println("Enter the length of the Rectangle");

  double l = kb3.nextInt();

  System.out.println("Enter the breadth of the Rectangle");

  double b = kb3.nextInt();

  double areaOfRectangle = l * b;

  System.out.println("Area of the Rectangle is" + areaOfRectangle);

 }

 @Override

 public void Triangle() {

  // TODO Auto-generated method stub

  Scanner kb4 = new Scanner(System.in);

  System.out.println("Enter the base of the Triangle");

  double base = kb4.nextInt();

  System.out.println("Enter the height of the Triangle");

  double h = kb4.nextInt();

  double areaOfTriangle = 0.5 * base * h;

  System.out.println("Area of the Triangle is" + areaOfTriangle);

 }

 public static void main(String[] args) {

  shapeArea geometry = new shapeArea();

  geometry.Circle();

  geometry.Square();

  geometry.Rectangle();

  geometry.Triangle();

 }

}

Abstract Classes in Java
abstract-classes

An abstract class is almost identical to an interface, but the difference is, an abstract class can incorporate data members and their method definitions.

Syntax:

<Access_Modifier> abstract class <Name_of_the_class> {

 <Data Members>;

 <Data Methods>;

}

Example:

package Simplilearn;

public abstract class Person {

 private String Name;

 private String Gender;

 public Person(String nm, String Gen) {

  this.Name = nm;

  this.Gender = Gen;

 }

 public abstract void work();

 @Override

 public String toString() {

  return "Name=" + this.Name + "::Gender=" + this.Gender;

 }

 public void changeName(String newName) {

  this.Name = newName;

 }

 public void Exam() {

  // TODO Auto-generated method stub

  

 }

}

Class

package abstraction;

public class Employee extends Person {

 private int EmpId;

 public Employee(String EmployeeName, String Gen, int EmployeeID) {

  super(EmployeeName, Gen);

  this.EmpId = EmployeeID;

 }

 @Override

 public void Office() {

  if (EmpId == 0) {

   System.out.println("Employee Logged Out");

  } else {

   System.out.println("Employee Logged In");

  }

 }

 public static void main(String args[]) {

  Person employee = new Employee("Pavithra", "Female", 1094826);

  employee.Office();

  employee.changeName("Pavithra Tripathy");

  System.out.println(employee.toString());

 }

}

Encapsulation in Java OOPs Concepts
encapsulation

Encapsulation is a procedure of binding the data members and data methods together inside the user-defined class, which should be declared private.

Syntax:

<Access_Modifier> class <Class_Name> {

 private <Data_Members>;

 private <Data_Methods>;

}

Example:

package Simplilearn;

public class emp {

 public static void main(String[] args) {

  encapsule emp = new encapsule();

  emp.setName("Robert");

  System.out.println(emp.Name());

 }

}

package Simplilearn;

public class encapsule {

 private String empName;

 public String Name() {

  return empName;

 }

 public void setName(String empName) {

  this.empName = empName;

 }

}

//Output:

Robert

Inheritance in Java OOPs Concepts 
Inheritance is one of the object-oriented programming approaches that simplify software development. It enables the ability to build new classes by inheriting data members and methods, as well as the properties of previously defined classes.

The inheriting class is called a child/derived class, and the inherited class is called the parent/base class. The process of inheriting the parent/base class is carried out in different ways. We will now discuss each one of them in detail. 

Types of Inheritance
Single
single

Single inheritance consists of one parent class and one child class. Here, child classes inherit parent class methods and data members.

Multi-level inheritance is also a parent-child inheritance relation, but the difference is another child class inherits the child class.

Java will not support multiple inheritance, as it ends up with a severe ambiguity.
Interface resolves the diamond problem.

Hierarchical inheritance is a parent-child relationship. The only difference is that multiple child classes inherit a single parent class.

The hybrid inheritance can be a combination of any of the three types of inheritances supported in Java.

When a class inherits an instance from a different class or an instance of its class, then the relation is a HAS-A type.

Example: Orange HAS-A citrus taste.

When a class inherits methods and members from different classes, then the relation is said to be an IS-A Relation.

Example: Orange IS-A Fruit. 

Polymorphism in Java OOPs Concepts 
Polymorphism is a Java programming language ability that is used to process an object, operator, and method in multiple ways based on the data type used, and the class implementing them. Many programming concepts explain the procedure of polymorphism in Java. 

The process of method overloading is achieved when a class has two or more methods with the same name, but the specific method is selected based on the number of parameters declared.

Method overriding is a procedure in which a child class is allowed to implement a specific class present in the parent class.

Operator Overloading and Operator Overriding
Java does not support operator overloading, nor operator overriding. The designers of the Java programming language understood the ambiguities of operator overloading and operator overriding in the C++ programming language. Hence, to avoid the complications, they have opted not to include operator overloading and operator overriding.

Static Polymorphism
Static polymorphism/compile-time polymorphism is executed during the compilation stage. Here, the overloading method is resolved in the compilation stage.

Dynamic Polymorphism
Dynamic polymorphism/run-time polymorphism is handled during the program execution stage. Here, the overriding method is resolved in the execution stage.

Super Keyword
The term "super" is a predefined keyword in Java that refers to the immediate parent class object or method defined in the program. In this procedure, whenever you create an instance of a subclass, then an instance of the parent class is also automatically created. The super reference variable will implicitly refer to that.

In object-oriented programming, the language offers accessibility to the object, method, and data member based on the access specifier defined. Similarly, in the Java programming language, we have four different access specifiers. 

Default
If the programmer does not provide the access specifier, the compiler will consider the default access specifier. In Java, the default access is public. However, this access is limited to the current package that the user is working on. The following is a visual coding example that can help to clarify this process: 

Public
The public access specifier provides access to the data members, methods, and objects universally.

Protected
The protected access specifier provides access to the data members, methods, and objects if the subclasses trying to access them are in the same package where the protected data is defined. Otherwise, the outside class should be extending the protected class, or else they will be inaccessible. 

Private
The access for private specifiers strictly limits the access of the variables and methods to only the class in which they are declared. Outside of that, they cannot be accessed.

Method Calling in Java OOPs Concepts
Java only supports call by value. Here, we pass the values to the specific method, and then after the implication of the method, we get the expected results.





